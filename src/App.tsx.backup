import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import DeckGL from '@deck.gl/react';
import { ScatterplotLayer, ArcLayer, ColumnLayer, PolygonLayer, BitmapLayer, PathLayer } from '@deck.gl/layers';
import { HeatmapLayer, GridLayer } from '@deck.gl/aggregation-layers';
import { FlyToInterpolator, COORDINATE_SYSTEM } from '@deck.gl/core';
import { Map as MapGL } from 'react-map-gl';
import maplibregl from 'maplibre-gl';
import { 
  ThemeProvider, createTheme, CssBaseline, Box, AppBar, Toolbar, Typography, 
  Tabs, Tab, Grid, Card, CardContent, Paper, Chip, Stack, IconButton, 
  Switch, FormControlLabel, Divider, Badge, alpha, Fade, Grow, Collapse, Button, LinearProgress, Tooltip
} from '@mui/material';
import { 
  ElectricBolt, Assessment, Warning, Engineering, TrendingUp,
  Speed, Memory, NetworkCheck, FilterList, Close, Refresh, ExpandMore, ExpandLess,
  MyLocation, ZoomIn, GridOn, BarChart, PieChart, PushPin, FavoriteOutlined, ElectricMeter,
  Whatshot, WbSunny, Thermostat, Opacity, SkipPrevious, FastRewind, PlayArrow, Pause, 
  FastForward, SkipNext, Layers, Power
} from '@mui/icons-material';
import 'maplibre-gl/dist/maplibre-gl.css';

const theme = createTheme({
  palette: {
    mode: 'dark',
    primary: { main: '#0EA5E9' },
    secondary: { main: '#FBBF24' },
    background: { default: '#0F172A', paper: '#1E293B' },
    success: { main: '#22C55E' },
    error: { main: '#EF4444' },
    warning: { main: '#F59E0B' },
    info: { main: '#3B82F6' }
  },
  typography: { fontFamily: 'Inter, system-ui, sans-serif' },
  components: {
    MuiCard: {
      styleOverrides: {
        root: { borderRadius: 8, boxShadow: '0 4px 12px rgba(0,0,0,0.3)' }
      }
    }
  }
});

const BASEMAP_URL = 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json';

const INITIAL_VIEW_STATE = {
  longitude: -95.3698,
  latitude: 29.7604,
  zoom: 9.5,  // Zoom out to show full Houston metro area (real utility data spans lat 28.94-30.48, lon -96.04 to -94.36)
  pitch: 45,
  bearing: 0,
  minPitch: 0,
  maxPitch: 45,  // deck.gl default is 60¬∞, but 45¬∞ prevents basemap desync in 3D views
  minZoom: 8,    // Prevent zooming out too far (was 0)
  maxZoom: 18    // Reasonable max for infrastructure detail (was 24)
};
interface AssetCluster {
  centroid: [number, number];
  assets: Asset[];
  substations: Asset[];
  transformers: Asset[];
  poles: Asset[];
  meters: Asset[];
  districtId?: string; // CNP-style service district ID (e.g., "BA-SD1", "AD-SD2")
}

// ENGINEERING: Substation-based operational clustering
// PROBLEM: Old approach used arbitrary 1km grid squares (unrealistic for utility operations)
// SOLUTION: Cluster assets by substation service areas (natural operational boundaries)
// BENEFIT: Aligns with utility actual grid management structure (competing with Grid 360)

// Helper: Generate CNP-style substation code (e.g., "BAMMEL" ‚Üí "BA", "ALDINE" ‚Üí "AD")
function generateSubstationCode(substationName: string): string {
  // Extract first letters of each word, max 3 characters
  const words = substationName.toUpperCase().split(/[\s_-]+/);
  if (words.length === 1) {
    return words[0].substring(0, 3);
  }
  // Take first letter of first 2-3 words
  return words.slice(0, Math.min(3, words.length)).map(w => w[0]).join('');
}

// Geographic subdivision helper - splits oversized clusters into service districts
function subdivideClusterGeographically(cluster: AssetCluster, numDistricts: number): AssetCluster[] {
  if (cluster.assets.length <= 1 || numDistricts <= 1) {
    return [cluster];
  }
  
  // K-means clustering to create geographic service districts within substation territory
  const assets = cluster.assets.filter(a => a.type !== 'substation'); // Exclude parent substation
  const centroids: [number, number][] = [];
  
  // Initialize centroids using k-means++ for better distribution
  centroids.push([assets[0].latitude, assets[0].longitude]);
  
  for (let i = 1; i < numDistricts && i < assets.length; i++) {
    let maxMinDist = -1;
    let bestAsset = assets[i];
    
    for (const asset of assets) {
      let minDist = Infinity;
      for (const centroid of centroids) {
        const dist = Math.sqrt(
          Math.pow(asset.latitude - centroid[0], 2) + 
          Math.pow(asset.longitude - centroid[1], 2)
        );
        minDist = Math.min(minDist, dist);
      }
      if (minDist > maxMinDist) {
        maxMinDist = minDist;
        bestAsset = asset;
      }
    }
    centroids.push([bestAsset.latitude, bestAsset.longitude]);
  }
  
  // Assign assets to nearest centroid
  // Generate substation code for service district naming
  const substationCode = cluster.substations.length > 0 
    ? generateSubstationCode(cluster.substations[0].name)
    : 'GC'; // Fallback to "GC" (Grid Cell) if no substation
  
  const districts: AssetCluster[] = centroids.map((centroid, idx) => ({
    centroid: [centroid[1], centroid[0]], // [lon, lat] for deck.gl
    assets: [],
    substations: cluster.substations, // Service districts reference parent substation
    transformers: [],
    poles: [],
    meters: [],
    // CNP-style service district ID: {SUBSTATION_CODE}-SD{NUMBER}
    districtId: `${substationCode}-SD${idx + 1}`
  }));
  
  assets.forEach(asset => {
    let nearestDistrict = 0;
    let minDist = Infinity;
    
    for (let i = 0; i < centroids.length; i++) {
      const dist = Math.sqrt(
        Math.pow(asset.latitude - centroids[i][0], 2) + 
        Math.pow(asset.longitude - centroids[i][1], 2)
      );
      if (dist < minDist) {
        minDist = dist;
        nearestDistrict = i;
      }
    }
    
    const district = districts[nearestDistrict];
    district.assets.push(asset);
    
    // Categorize by asset type
    if (asset.type === 'transformer') {
      district.transformers.push(asset);
    } else if (asset.type === 'pole') {
      district.poles.push(asset);
    } else if (asset.type === 'meter') {
      district.meters.push(asset);
    }
  });
  
  // Recalculate district centroids based on actual asset positions
  districts.forEach(district => {
    if (district.assets.length > 0) {
      const avgLat = district.assets.reduce((sum, a) => sum + a.latitude, 0) / district.assets.length;
      const avgLon = district.assets.reduce((sum, a) => sum + a.longitude, 0) / district.assets.length;
      district.centroid = [avgLon, avgLat];
    }
  });
  
  // Filter out empty districts
  return districts.filter(d => d.assets.length > 0);
}

function substationBasedClustering(substations: Asset[], transformers: Asset[], poles: Asset[], meters: Asset[]): AssetCluster[] {
  // INSIGHT: Utilities organize operations by substations (not arbitrary geographic grids)
  // Each substation serves ~5,000-10,000 customers and defines a natural operational zone
  
  // Haversine distance calculation for accurate geospatial clustering
  const haversineDistance = (lat1: number, lon1: number, lat2: number, lon2: number): number => {
    const R = 6371; // Earth radius in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  };
  
  // Create operational clusters centered on each substation
  const clusters: AssetCluster[] = substations.map(substation => ({
    centroid: [substation.longitude, substation.latitude],
    assets: [substation], // Include the substation itself
    substations: [substation],
    transformers: [],
    poles: [],
    meters: []
  }));
  
  // If no substations exist, fall back to geographic clustering
  if (substations.length === 0) {
    console.warn('‚ö†Ô∏è No substations found - falling back to geographic clustering');
    return gridBinAssets([...transformers, ...poles, ...meters], 0.01);
  }
  
  // REALISTIC DISTRIBUTION: CNP-style service area boundaries with distance weighting
  // Edge substations have smaller service areas (sparser), central have larger (denser)
  // Distance penalty prevents edge substations from "vacuuming up" outlying assets
  const MAX_SERVICE_RADIUS_KM = 25; // Extended for outlying areas
  const PREFERRED_SERVICE_RADIUS_KM = 12; // Typical service radius
  
  // Assign transformers with distance-weighted preference
  transformers.forEach(transformer => {
    let nearestCluster = clusters[0];
    let minDistance = haversineDistance(
      transformer.latitude, transformer.longitude,
      nearestCluster.substations[0].latitude, nearestCluster.substations[0].longitude
    );
    
    for (let i = 1; i < clusters.length; i++) {
      const distance = haversineDistance(
        transformer.latitude, transformer.longitude,
        clusters[i].substations[0].latitude, clusters[i].substations[0].longitude
      );
      if (distance < minDistance) {
        minDistance = distance;
        nearestCluster = clusters[i];
      }
    }
    
    // Assign to nearest substation within max service radius
    // Assets beyond 25km are considered outside service territory (realistic boundary)
    if (minDistance <= MAX_SERVICE_RADIUS_KM) {
      nearestCluster.transformers.push(transformer);
      nearestCluster.assets.push(transformer);
    }
  });
  
  // Assign poles with distance-weighted preference
  poles.forEach(pole => {
    let nearestCluster = clusters[0];
    let minDistance = haversineDistance(
      pole.latitude, pole.longitude,
      nearestCluster.substations[0].latitude, nearestCluster.substations[0].longitude
    );
    
    for (let i = 1; i < clusters.length; i++) {
      const distance = haversineDistance(
        pole.latitude, pole.longitude,
        clusters[i].substations[0].latitude, clusters[i].substations[0].longitude
      );
      if (distance < minDistance) {
        minDistance = distance;
        nearestCluster = clusters[i];
      }
    }
    
    // Assign to nearest substation within max service radius
    if (minDistance <= MAX_SERVICE_RADIUS_KM) {
      nearestCluster.poles.push(pole);
      nearestCluster.assets.push(pole);
    }
  });
  
  // Assign meters with distance-weighted preference
  meters.forEach(meter => {
    let nearestCluster = clusters[0];
    let minDistance = haversineDistance(
      meter.latitude, meter.longitude,
      nearestCluster.substations[0].latitude, nearestCluster.substations[0].longitude
    );
    
    for (let i = 1; i < clusters.length; i++) {
      const distance = haversineDistance(
        meter.latitude, meter.longitude,
        clusters[i].substations[0].latitude, clusters[i].substations[0].longitude
      );
      if (distance < minDistance) {
        minDistance = distance;
        nearestCluster = clusters[i];
      }
    }
    
    // Assign to nearest substation within max service radius
    if (minDistance <= MAX_SERVICE_RADIUS_KM) {
      nearestCluster.meters.push(meter);
      nearestCluster.assets.push(meter);
    }
  });
  
  // SERVICE DISTRICT SUBDIVISION: Split oversized clusters into geographic zones
  // Realistic distribution: Average ~720 assets/substation, max ~1800 (2.5x avg) before subdivision
  const SUBDIVISION_THRESHOLD = 1800;
  const finalClusters: AssetCluster[] = [];
  
  clusters.forEach(cluster => {
    if (cluster.assets.length <= SUBDIVISION_THRESHOLD) {
      // Cluster is reasonably sized - keep as-is
      finalClusters.push(cluster);
    } else {
      // Oversized cluster - subdivide into geographic service districts
      const numDistricts = Math.ceil(cluster.assets.length / 900); // Target ~900 assets per district
      const districts = subdivideClusterGeographically(cluster, numDistricts);
      finalClusters.push(...districts);
    }
  });
  
  // Log operational clustering results with subdivision statistics
  const totalAssigned = finalClusters.reduce((sum, c) => sum + c.assets.length, 0);
  const totalAssets = transformers.length + poles.length + meters.length;
  const subdivisionInfo = finalClusters.length > clusters.length ? 
    ` (${finalClusters.length - clusters.length} service districts created)` : '';
  
  // Disable clustering logs in production for performance
  // To enable: set localStorage.debug = 'flux:clustering' in console
  
  return finalClusters;
}

// LEGACY: Keep old gridBinAssets as fallback for non-substation scenarios
function gridBinAssets(assets: Asset[], cellSize: number = 0.01): AssetCluster[] {
  // cellSize in degrees (~1km at Houston latitude)
  const gridMap = new Map<string, AssetCluster>();

  assets.forEach(asset => {
    // Calculate grid cell coordinates
    const cellX = Math.floor(asset.longitude / cellSize);
    const cellY = Math.floor(asset.latitude / cellSize);
    const cellKey = `${cellX},${cellY}`;

    if (!gridMap.has(cellKey)) {
      // Initialize new grid cell with centroid at cell center
      gridMap.set(cellKey, {
        centroid: [
          (cellX + 0.5) * cellSize,
          (cellY + 0.5) * cellSize
        ],
        assets: [],
        substations: [],
        transformers: [],
        poles: [],
        meters: []
      });
    }

    const cell = gridMap.get(cellKey)!;
    cell.assets.push(asset);
    
    // Case-insensitive type matching
    const assetType = asset.type?.toLowerCase();
    if (assetType === 'substation') cell.substations.push(asset);
    if (assetType === 'transformer') cell.transformers.push(asset);
    if (assetType === 'pole') cell.poles.push(asset);
    if (assetType === 'meter') cell.meters.push(asset);
  });

  return Array.from(gridMap.values());
}

function getJitteredPosition(asset: Asset, jitterDistance: number): [number, number] {
  const hash = asset.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
  const angleRadians = ((hash % 360) * Math.PI) / 180;
  const lonOffset = jitterDistance * Math.cos(angleRadians);
  const latOffset = jitterDistance * Math.sin(angleRadians);
  return [asset.longitude + lonOffset, asset.latitude + latOffset];
}

// Helper function to generate rectangular prism polygon (for transformers)
function getRectangularPrism(centerLon: number, centerLat: number, widthMeters: number, depthMeters: number): number[][] {
  // Convert meters to approximate degrees (rough approximation at Houston latitude ~30¬∞)
  const metersToDegreesLon = 1 / 111320 / Math.cos(29.7604 * Math.PI / 180);
  const metersToDegreesLat = 1 / 110540;
  
  const halfWidth = (widthMeters * metersToDegreesLon) / 2;
  const halfDepth = (depthMeters * metersToDegreesLat) / 2;
  
  return [
    [centerLon - halfWidth, centerLat - halfDepth],
    [centerLon + halfWidth, centerLat - halfDepth],
    [centerLon + halfWidth, centerLat + halfDepth],
    [centerLon - halfWidth, centerLat + halfDepth],
    [centerLon - halfWidth, centerLat - halfDepth] // Close the polygon
  ];
}

// Helper function to generate cube polygon (square base for extruded cube)
function getCubePolygon(centerLon: number, centerLat: number, sizeMeters: number): number[][] {
  return getRectangularPrism(centerLon, centerLat, sizeMeters, sizeMeters);
}

// Helper function to generate pyramid polygon (triangular base)
function getPyramidPolygon(centerLon: number, centerLat: number, sizeMeters: number): number[][] {
  const metersToDegreesLon = 1 / 111320 / Math.cos(29.7604 * Math.PI / 180);
  const metersToDegreesLat = 1 / 110540;
  
  const halfSize = (sizeMeters * metersToDegreesLon) / 2;
  const height = halfSize * Math.sqrt(3); // Equilateral triangle height
  
  return [
    [centerLon, centerLat + height * 2/3], // Top vertex
    [centerLon - halfSize, centerLat - height * 1/3], // Bottom left
    [centerLon + halfSize, centerLat - height * 1/3], // Bottom right
    [centerLon, centerLat + height * 2/3] // Close the polygon
  ];
}

// Helper function to generate hexagon polygon (for substations)
function getHexagonPolygon(centerLon: number, centerLat: number, sizeMeters: number): number[][] {
  const metersToDegreesLon = 1 / 111320 / Math.cos(29.7604 * Math.PI / 180);
  const metersToDegreesLat = 1 / 110540;
  
  const radiusLon = (sizeMeters * metersToDegreesLon) / 2;
  const radiusLat = (sizeMeters * metersToDegreesLat) / 2;
  
  const vertices: number[][] = [];
  for (let i = 0; i < 6; i++) {
    const angle = (Math.PI / 3) * i; // 60 degrees between vertices
    vertices.push([
      centerLon + radiusLon * Math.cos(angle),
      centerLat + radiusLat * Math.sin(angle)
    ]);
  }
  vertices.push(vertices[0]); // Close the polygon
  
  return vertices;
}

interface Asset {
  id: string;
  name: string;
  type: 'pole' | 'transformer' | 'meter' | 'substation';
  latitude: number;
  longitude: number;
  health_score?: number;
  load_percent?: number;
  usage_kwh?: number;
  voltage?: string;
  status?: string;
  last_maintenance?: string;
  commissioned_date?: string;
  pole_height_ft?: number;
}

interface TopologyLink {
  from_asset_id: string;
  to_asset_id: string;
  connection_type: string;
  from_latitude: number;
  from_longitude: number;
  to_latitude: number;
  to_longitude: number;
}

interface KPICardProps {
  title: string;
  value: string | number;
  subtitle?: string;
  icon: React.ReactNode;
  color: string;
  trend?: number;
  sx?: any;
}

function KPICard({ title, value, subtitle, icon, color, trend, sx }: KPICardProps) {
  return (
    <Card sx={{ height: '100%', bgcolor: 'background.paper', borderLeft: `3px solid ${color}`, ...sx }}>
      <CardContent sx={{ p: 1.5, '&:last-child': { pb: 1.5 } }}>
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 0.5 }}>
          <Typography variant="overline" sx={{ fontSize: '0.65rem', letterSpacing: 0.5 }} color="text.secondary" fontWeight={600}>{title}</Typography>
          <Box sx={{ color, fontSize: 16 }}>{icon}</Box>
        </Box>
        <Typography variant="h4" sx={{ fontWeight: 700, fontSize: '1.75rem', lineHeight: 1.2 }}>{value}</Typography>
        {subtitle && <Typography variant="caption" sx={{ fontSize: '0.7rem' }} color="text.secondary">{subtitle}</Typography>}
        {trend !== undefined && (
          <Chip 
            label={`${trend > 0 ? '+' : ''}${trend}%`} 
            size="small" 
            sx={{ 
              mt: 0.5,
              height: 18,
              fontSize: '0.65rem',
              bgcolor: trend > 0 ? alpha('#22C55E', 0.2) : alpha('#EF4444', 0.2),
              color: trend > 0 ? '#22C55E' : '#EF4444',
              fontWeight: 600
            }} 
          />
        )}
      </CardContent>
    </Card>
  );
}

function App() {
  const [currentTab, setCurrentTab] = useState(0);
  const [isLoadingData, setIsLoadingData] = useState(true);
  const [assets, setAssets] = useState<Asset[]>([]);
  const dataFetchedRef = useRef(false); // Prevent duplicate fetches
  const [topology, setTopology] = useState<TopologyLink[]>([]);
  const [metroTopologyData, setMetroTopologyData] = useState<any[]>([]);
  const [feederTopologyData, setFeederTopologyData] = useState<any[]>([]);
  const [weather, setWeather] = useState<any[]>([]);
  const [weatherTimelineIndex, setWeatherTimelineIndex] = useState(0);
  const [isWeatherPlaying, setIsWeatherPlaying] = useState(false);
  const [weatherSpeed, setWeatherSpeed] = useState(1);
  const [selectedAsset, setSelectedAsset] = useState<Asset | null>(null);
  const [selectedAssetPosition, setSelectedAssetPosition] = useState<{ x: number; y: number } | null>(null);
  const [clickPosition, setClickPosition] = useState<{ x: number; y: number } | null>(null);
  const [pinnedAssets, setPinnedAssets] = useState<Array<{asset: Asset, position: {x: number, y: number}, id: string, collapsed: boolean}>>([]);
  const [draggedCardId, setDraggedCardId] = useState<string | null>(null);
  const [dragOffset, setDragOffset] = useState<{x: number, y: number}>({x: 0, y: 0});
  const [dragVelocity, setDragVelocity] = useState<{x: number, y: number}>({x: 0, y: 0});
  const dragPositionHistory = useRef<Array<{x: number, y: number, time: number}>>([]);
  const momentumAnimationRef = useRef<number | null>(null);
  const [viewState, setViewState] = useState(INITIAL_VIEW_STATE);
  const isProgrammaticTransition = useRef(false);
  const viewportUpdateTimer = useRef<NodeJS.Timeout | null>(null);
  const pendingViewState = useRef<any>(null);
  const [expandedSections, setExpandedSections] = useState({
    infrastructure: true,
    health: true,
    distribution: false
  });
  const [expandedAssetCategories, setExpandedAssetCategories] = useState<{
    [cardId: string]: {
      substations: boolean;
      transformers: boolean;
      poles: boolean;
      meters: boolean;
    }
  }>({});
  const [snapEnabled, setSnapEnabled] = useState(true);

  useEffect(() => {
    if (!draggedCardId) return;

    const handleMouseMove = (e: MouseEvent) => {
      const newX = Math.max(0, Math.min(e.clientX - dragOffset.x, window.innerWidth - 380));
      const newY = Math.max(0, Math.min(e.clientY - dragOffset.y, window.innerHeight - 100));
      
      // Track position history for velocity calculation
      dragPositionHistory.current.push({ x: newX, y: newY, time: Date.now() });
      if (dragPositionHistory.current.length > 5) {
        dragPositionHistory.current.shift();
      }
      
      // Update pinned assets
      setPinnedAssets(prev => prev.map(p => 
        p.id === draggedCardId ? { ...p, position: { x: newX, y: newY } } : p
      ));
      
      // Update selected asset position if dragging the selected card
      if (selectedAsset && draggedCardId === selectedAsset.id) {
        setSelectedAssetPosition({ x: newX, y: newY });
      }
    };

    const handleMouseUp = () => {
      // Calculate velocity from position history
      if (dragPositionHistory.current.length >= 2) {
        const last = dragPositionHistory.current[dragPositionHistory.current.length - 1];
        const first = dragPositionHistory.current[0];
        const timeDelta = (last.time - first.time) / 1000; // seconds
        
        if (timeDelta > 0) {
          const velocityX = (last.x - first.x) / timeDelta;
          const velocityY = (last.y - first.y) / timeDelta;
          
          // Start momentum animation
          startMomentumAnimation(draggedCardId, velocityX, velocityY);
        }
      }
      
      setDraggedCardId(null);
      dragPositionHistory.current = [];
    };

    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);

    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [draggedCardId, dragOffset, selectedAsset]);

  // Momentum animation after drag release
  const startMomentumAnimation = (cardId: string, initialVelocityX: number, initialVelocityY: number) => {
    let velocityX = initialVelocityX;
    let velocityY = initialVelocityY;
    const friction = 0.85; // Increased friction (was 0.92) - more decay per frame
    const minVelocity = 1.5; // Increased threshold (was 0.5) - stops sooner
    let lastTimestamp = performance.now();
    
    const animate = (timestamp: number) => {
      // Calculate actual time delta for smooth 60fps animation
      const deltaTime = Math.min((timestamp - lastTimestamp) / 16.667, 2); // Cap at 2x for safety
      lastTimestamp = timestamp;
      
      // Apply friction with time correction
      const frictionFactor = Math.pow(friction, deltaTime);
      velocityX *= frictionFactor;
      velocityY *= frictionFactor;
      
      // Stop if velocity is too small
      if (Math.abs(velocityX) < minVelocity && Math.abs(velocityY) < minVelocity) {
        momentumAnimationRef.current = null;
        return;
      }
      
      // Update position with time-corrected delta
      const deltaX = (velocityX / 60) * deltaTime;
      const deltaY = (velocityY / 60) * deltaTime;
      
      setPinnedAssets(prev => prev.map(p => {
        if (p.id === cardId) {
          const newX = Math.max(0, Math.min(p.position.x + deltaX, window.innerWidth - 380));
          const newY = Math.max(0, Math.min(p.position.y + deltaY, window.innerHeight - 100));
          
          // Stop if hitting boundary
          if (newX === 0 || newX === window.innerWidth - 380) velocityX = 0;
          if (newY === 0 || newY === window.innerHeight - 100) velocityY = 0;
          
          return { ...p, position: { x: newX, y: newY } };
        }
        return p;
      }));
      
      // Update selected asset if it's the one being animated
      if (selectedAsset && cardId === selectedAsset.id) {
        setSelectedAssetPosition(prev => {
          if (!prev) return null;
          const newX = Math.max(0, Math.min(prev.x + deltaX, window.innerWidth - 380));
          const newY = Math.max(0, Math.min(prev.y + deltaY, window.innerHeight - 100));
          
          if (newX === 0 || newX === window.innerWidth - 380) velocityX = 0;
          if (newY === 0 || newY === window.innerHeight - 100) velocityY = 0;
          
          return { x: newX, y: newY };
        });
      }
      
      momentumAnimationRef.current = requestAnimationFrame(animate);
    };
    
    if (momentumAnimationRef.current) {
      cancelAnimationFrame(momentumAnimationRef.current);
    }
    momentumAnimationRef.current = requestAnimationFrame(animate);
  };

  // Cleanup momentum animation on unmount
  useEffect(() => {
    return () => {
      if (momentumAnimationRef.current) {
        cancelAnimationFrame(momentumAnimationRef.current);
      }
    };
  }, []);
  const [zoomTimeout, setZoomTimeout] = useState<NodeJS.Timeout | null>(null);
  const [lastZoomVelocity, setLastZoomVelocity] = useState(0);
  const lastZoomTimeRef = useRef(Date.now());
  const lastZoomRef = useRef(INITIAL_VIEW_STATE.zoom);
  const [isInMagneticZone, setIsInMagneticZone] = useState(false);
  const [targetSnapZoom, setTargetSnapZoom] = useState<number | null>(null);
  const isSnappingRef = useRef(false);
  const velocityHistoryRef = useRef<Array<{velocity: number, time: number}>>([]);
  const isUserScrollingRef = useRef(false);
  const scrollEndTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const [lastClickTime, setLastClickTime] = useState(0);
  const [lastClickCoords, setLastClickCoords] = useState<[number, number] | null>(null);
  const [animationFrame, setAnimationFrame] = useState(0);
  const [layersVisible, setLayersVisible] = useState({
    poles: true,
    transformers: true,
    meters: true,
    substations: true,
    connections: true,
    heatmap: false,
    weather: false,
    enable3D: true
  });
  const [layersPanelExpanded, setLayersPanelExpanded] = useState(true);

  // Auto-disable expensive heatmap when weather overlay is enabled (GPU optimization)
  useEffect(() => {
    if (layersVisible.weather && layersVisible.heatmap) {
      setLayersVisible(prev => ({ ...prev, heatmap: false }));
      console.log('‚ö° GPU Optimization: Disabled usage heatmap (conflicts with weather overlay)');
    }
  }, [layersVisible.weather, layersVisible.heatmap]);

  // Weather timeline animation loop
  useEffect(() => {
    if (!isWeatherPlaying || weather.length === 0) return;

    const interval = setInterval(() => {
      setWeatherTimelineIndex(prev => {
        // Loop back to start when reaching the end
        if (prev >= weather.length - 1) return 0;
        return prev + 1;
      });
    }, 1000 / weatherSpeed); // Speed controls how many hours per second

    return () => clearInterval(interval);
  }, [isWeatherPlaying, weather.length, weatherSpeed]);

  // Extract currentZoom early for use in callbacks
  const currentZoom = viewState.zoom;
  const ZOOM_THRESHOLD = 11.5;
  const useClusteredView = currentZoom < ZOOM_THRESHOLD;

  // PERFORMANCE: Throttle zoom for expensive calculations - only update on significant changes
  const throttledZoom = useMemo(() => {
    return Math.round(currentZoom * 2) / 2;
  }, [currentZoom]);

  // VIEWPORT-FILTERED TOPOLOGY: Smoothly tracks visible connections with fade transitions
  // Uses throttledZoom to prevent recalculation on every tiny zoom change
  const visibleTopology = useMemo(() => {
    if (throttledZoom < 10 || topology.length === 0) return [];
    
    const zoom = throttledZoom;
    const degPerPixel = 360 / (256 * Math.pow(2, zoom));
    const viewWidth = (typeof window !== 'undefined' ? window.innerWidth : 1920) * degPerPixel;
    const viewHeight = (typeof window !== 'undefined' ? window.innerHeight : 1080) * degPerPixel;
    
    const halfViewWidth = viewWidth / 2;
    const halfViewHeight = viewHeight / 2;
    const bufferMultiplier = 0.6;
    
    const minLng = viewState.longitude - halfViewWidth * bufferMultiplier;
    const maxLng = viewState.longitude + halfViewWidth * bufferMultiplier;
    const minLat = viewState.latitude - halfViewHeight * bufferMultiplier;
    const maxLat = viewState.latitude + halfViewHeight * bufferMultiplier;
    
    const viewportFiltered = topology.filter(link => 
      (link.from_longitude >= minLng && link.from_longitude <= maxLng &&
       link.from_latitude >= minLat && link.from_latitude <= maxLat) ||
      (link.to_longitude >= minLng && link.to_longitude <= maxLng &&
       link.to_latitude >= minLat && link.to_latitude <= maxLat)
    );
    
    if (selectedAsset) {
      const selectedConnections = topology.filter(link =>
        link.from_asset_id === selectedAsset.id || link.to_asset_id === selectedAsset.id
      );
      
      const viewportIds = new Set(viewportFiltered.map(l => `${l.from_asset_id}-${l.to_asset_id}`));
      const uniqueSelected = selectedConnections.filter(l => 
        !viewportIds.has(`${l.from_asset_id}-${l.to_asset_id}`)
      );
      
      return [...viewportFiltered, ...uniqueSelected].slice(0, 8000);
    }
    
    return viewportFiltered.slice(0, 8000);
  }, [viewState.longitude, viewState.latitude, throttledZoom, topology, selectedAsset]);

  // Fly to asset location with buttery smooth animation
  const flyToAsset = (longitude: number, latitude: number, zoom?: number) => {
    isProgrammaticTransition.current = true;
    setViewState({
      longitude,
      latitude,
      zoom: zoom || 13.5,
      pitch: viewState.pitch,
      bearing: viewState.bearing,
      transitionDuration: 2000, // Smooth, cinematic duration
      transitionInterpolator: new FlyToInterpolator({ speed: 1.2 }) // Optimized speed for smoothness
    });
    // Reset flag after transition completes
    setTimeout(() => {
      isProgrammaticTransition.current = false;
    }, 2100);
  };

  // Smooth zoom on double-click
  const handleDoubleClick = (info: any) => {
    // Determine zoom direction based on modifier keys
    // Shift + double-click = zoom out, otherwise zoom in
    const zoomOut = info.srcEvent?.shiftKey;
    const zoomDelta = zoomOut ? -1.5 : 1.5;
    const newZoom = Math.max(5, Math.min(15, currentZoom + zoomDelta));
    
    isProgrammaticTransition.current = true;
    setViewState({
      ...viewState,
      zoom: newZoom,
      longitude: info.coordinate ? info.coordinate[0] : viewState.longitude,
      latitude: info.coordinate ? info.coordinate[1] : viewState.latitude,
      transitionDuration: 1000, // Smooth zoom duration
      transitionInterpolator: new FlyToInterpolator({ speed: 1.5 })
    });
    // Reset flag after transition completes
    setTimeout(() => {
      isProgrammaticTransition.current = false;
    }, 1100);
  };

  // ENGINEERING ENHANCEMENT: Priority-based glow system
  // Communicates operational urgency through color, intensity, pulse speed
  const getGlowProperties = useCallback((asset: any) => {
    const health = asset.health_score ?? 75;
    const load = asset.load_percent ?? 50;
    
    // Intelligence layer zoom adaptation
    const glowScale = currentZoom < 10.8 ? 1.5 :  // Executive view - large regional glow
                      currentZoom < 12.2 ? 1.2 :  // Incident view - medium glow
                      currentZoom < 13.5 ? 1.0 :  // Inspection view - normal glow
                      0.8;                         // Engineering view - tight glow
    
    // CRITICAL: Red glow - poor health or overloaded
    if (health < 50 || load > 85) {
      return {
        baseColor: [239, 68, 68],     // Red
        pulseSpeed: 0.15,              // Fast pulse (urgent)
        pulseAmplitude: 1.2,           // Stronger pulse
        glowScale: glowScale,
        label: 'CRITICAL',
        strokeIntensity: 1.0
      };
    }
    // WARNING: Amber glow - fair health or high load
    else if (health < 70 || load > 70) {
      return {
        baseColor: [251, 191, 36],    // Amber
        pulseSpeed: 0.11,              // Medium pulse
        pulseAmplitude: 1.0,
        glowScale: glowScale,
        label: 'WARNING',
        strokeIntensity: 0.8
      };
    }
    // HEALTHY: Green glow - good status
    else {
      return {
        baseColor: [34, 197, 94],     // Green - matches grid cell colors
        pulseSpeed: 0.08,              // Slow pulse (calm)
        pulseAmplitude: 0.8,
        glowScale: glowScale,
        label: 'HEALTHY',
        strokeIntensity: 0.6
      };
    }
  }, [currentZoom]);

  useEffect(() => {
    // Load real utility data from Snowflake
    async function loadRealData() {
      // Prevent duplicate fetches (especially in development)
      if (dataFetchedRef.current) {
        console.log('‚è≠Ô∏è  Data already loaded, skipping fetch');
        return;
      }
      dataFetchedRef.current = true;
      
      setIsLoadingData(true);
      try {
        // Fetch assets
        console.log('üîÑ Fetching assets from backend...');
        const assetsRes = await fetch('/api/assets');
        
        if (!assetsRes.ok) {
          throw new Error(`HTTP ${assetsRes.status}: ${assetsRes.statusText}`);
        }
        
        const contentLength = assetsRes.headers.get('content-length');
        console.log(`üì¶ Response size: ${contentLength ? (parseInt(contentLength) / 1024 / 1024).toFixed(2) + ' MB' : 'unknown'}`);
        
        const assetsData = await assetsRes.json();
        console.log(`‚úÖ Received ${assetsData.length} assets from backend`);
        
        // Fetch topology
        const topologyRes = await fetch('/api/topology');
        const topologyData = await topologyRes.json();
        
        // Fetch metro topology (for zoom < 9)
        const metroRes = await fetch('/api/topology/metro');
        const metroData = await metroRes.json();
        
        // Fetch feeder topology (for zoom 9-11.5)
        const feederRes = await fetch('/api/topology/feeders');
        const feederData = await feederRes.json();
        
        // Fetch weather
        const weatherRes = await fetch('/api/weather');
        const weatherData = await weatherRes.json();
        
        // Map Snowflake data to Asset format
        const mappedAssets: Asset[] = assetsData.map((row: any) => ({
          id: row.ASSET_ID,
          name: row.ASSET_NAME,
          type: row.ASSET_TYPE,
          latitude: row.LATITUDE,
          longitude: row.LONGITUDE,
          load_percent: row.LOAD_PERCENT,
          voltage: row.VOLTAGE,
          status: row.STATUS,
          commissioned_date: row.COMMISSIONED_DATE,
          health_score: row.HEALTH_SCORE,
          usage_kwh: row.USAGE_KWH,
          pole_height_ft: row.POLE_HEIGHT_FT
        }));
        
        setAssets(mappedAssets);
        setWeather(weatherData);
        setMetroTopologyData(metroData);
        setFeederTopologyData(feederData);
        setTopology(topologyData.map((row: any) => ({
          from_asset_id: row.FROM_ASSET_ID,
          to_asset_id: row.TO_ASSET_ID,
          connection_type: 'Distribution',
          from_latitude: row.FROM_LAT,
          from_longitude: row.FROM_LON,
          to_latitude: row.TO_LAT,
          to_longitude: row.TO_LON
        })));
        
        console.log(`Loaded ${mappedAssets.length} real assets, ${topologyData.length} topology links, ${metroData.length} metro areas, ${feederData.length} feeders, ${weatherData.length} weather records from Snowflake`);
      } catch (error) {
        console.error('Failed to load data from backend:', error);
        console.error('Error details:', {
          message: error.message,
          stack: error.stack
        });
      } finally {
        setIsLoadingData(false);
      }
    }
    
    loadRealData();

    // Auto-refresh KPIs - NOW CALCULATED FROM REAL GRID DATA
    // Metrics update automatically via useMemo dependency on flattenedClusterData
    // No artificial simulation needed - metrics reflect actual grid cell status
  }, []);

  // INFORMATION LAYER ARCHITECTURE - Premium snap-to-intelligence
  // Each layer reveals distinct operational intelligence, not arbitrary zoom levels
  const INTELLIGENCE_LAYERS = {
    EXECUTIVE_DASHBOARD: { 
      zoom: 9.5, 
      name: "Executive Dashboard",
      description: "Regional health & aggregate KPIs"
    },
    CRITICAL_INCIDENT_MAP: { 
      zoom: 10.8, 
      name: "Critical Incident Map",
      description: "Priority assets requiring attention"
    },
    ASSET_INSPECTION: { 
      zoom: 12.2, 
      name: "Asset Inspection View",
      description: "Individual asset details"
    },
    ENGINEERING_DETAIL: { 
      zoom: 13.5, 
      name: "Engineering Detail",
      description: "Full topology & connections"
    }
  };
  
  // Apple trackpad velocity tracking with momentum detection
  useEffect(() => {
    const now = Date.now();
    const timeDelta = now - lastZoomTimeRef.current;
    const zoomDelta = currentZoom - lastZoomRef.current;
    
    if (timeDelta > 0 && timeDelta < 100) {
      const velocity = Math.abs(zoomDelta) / timeDelta * 1000;
      setLastZoomVelocity(velocity);
      
      // Track velocity history for momentum detection (trackpad gestures)
      velocityHistoryRef.current.push({ velocity, time: now });
      
      // Keep only last 150ms of history
      velocityHistoryRef.current = velocityHistoryRef.current.filter(
        v => now - v.time < 150
      );
      
      // Detect active scrolling (trackpad gesture in progress)
      if (velocity > 0.5) {
        isUserScrollingRef.current = true;
        
        // Clear existing scroll end timeout
        if (scrollEndTimeoutRef.current) {
          clearTimeout(scrollEndTimeoutRef.current);
        }
        
        // Wait for scrolling to fully stop (trackpad momentum complete)
        scrollEndTimeoutRef.current = setTimeout(() => {
          isUserScrollingRef.current = false;
        }, 80); // Short window for trackpad momentum
      }
    }
    
    lastZoomTimeRef.current = now;
    lastZoomRef.current = currentZoom;
  }, [currentZoom]);
  
  // Animation loop for selection glow effect
  useEffect(() => {
    if (!selectedAsset) return;
    
    const interval = setInterval(() => {
      setAnimationFrame(prev => prev + 1);
    }, 16); // 60 FPS for smooth selection animation
    
    return () => clearInterval(interval);
  }, [selectedAsset]);
  
  // Reset expanded asset categories when selection changes
  const prevSelectedAssetId = useRef<string | null>(null);
  useEffect(() => {
    const currentId = selectedAsset?.id || null;
    if (currentId !== prevSelectedAssetId.current) {
      prevSelectedAssetId.current = currentId;
      setExpandedAssetCategories({
        substations: false,
        transformers: false,
        poles: false
      });
    }
  }, [selectedAsset]);
  
  // Apple trackpad-optimized magnetic snap system - DISABLED
  useEffect(() => {
    // DISABLED: Snap system was fighting user zoom input
    // Clear any existing timeouts to prevent fighting
    if (zoomTimeout) clearTimeout(zoomTimeout);
    return () => {
      if (zoomTimeout) clearTimeout(zoomTimeout);
    };
  }, []);
  
  // Tower scale animation: grows progressively from 0 to 1 as you zoom out past threshold
  // Creates smooth emergence effect when switching from individual to aggregate view
  const towerScaleAnimation = useMemo(() => {
    if (currentZoom >= ZOOM_THRESHOLD) return 0; // Completely flat when showing individual assets
    
    // Transition zone: from ZOOM_THRESHOLD down to ZOOM_THRESHOLD - 1.5
    const transitionRange = 1.5;
    const zoomDelta = ZOOM_THRESHOLD - currentZoom;
    
    // Smoothly scale from 0 to 1 using easeOutCubic
    const linearScale = Math.min(1, zoomDelta / transitionRange);
    return linearScale * linearScale * (3 - 2 * linearScale); // Smoothstep function
  }, [currentZoom]);

  // Individual asset scale animation: inverse of tower scale
  // Grows from 0 to 1 as you zoom in past threshold
  // Use currentZoom for smooth animation, not throttledZoom
  // EXTENDED RANGE: Requires more zoom to fully reveal all assets (slower, more dramatic emergence)
  const assetScaleAnimation = useMemo(() => {
    if (currentZoom <= ZOOM_THRESHOLD - 1.5) return 0;
    
    const transitionRange = 3.5; // Increased from 2.0 - requires more zoom to complete
    const zoomDelta = currentZoom - (ZOOM_THRESHOLD - 1.5);
    
    const linearScale = Math.min(1, zoomDelta / transitionRange);
    return linearScale * linearScale * (3 - 2 * linearScale);
  }, [currentZoom]);

  // OPERATIONAL TRIAGE PATTERN: Priority-based emergence for operational intelligence
  // Critical assets appear first (0-30%), warnings next (30-70%), healthy last (70-100%)
  // This guides #attention to problems, not just pretty animation
  // Simplified stagger calculation - removed expensive trig ops for performance
  const getStaggerDelay = (
    longitude: number, 
    latitude: number, 
    baseAnimation: number,
    healthScore?: number,
    loadPercent?: number,
    assetType?: string
  ) => {
    if (baseAnimation === 0) return 0;
    if (baseAnimation === 1) return 1;
    
    // TYPE-SPECIFIC SLOWDOWN: Dramatic emergence for key infrastructure
    // Substations, transformers, poles emerge close together (core infrastructure)
    let typeSlowdown = 1.0;
    let animationOffset = 0.0; // Head start for certain asset types
    
    if (assetType === 'substation') typeSlowdown = 0.5; // 2x slower
    if (assetType === 'transformer') typeSlowdown = 0.6; // 1.67x slower
    if (assetType === 'pole') {
      typeSlowdown = 0.80; // Balanced slowdown
      animationOffset = 0.20; // Moderate head start
    }
    
    // Apply offset and type slowdown to base animation
    const adjustedBaseAnimation = Math.min(1, (baseAnimation + animationOffset) * typeSlowdown);
    
    // Determine priority tier based on health and load
    // EXCEPTION: Poles always appear shortly after subs/xfmrs (tier 2)
    let priorityTier = 3; // Default: healthy (70-100% of animation)
    
    if (assetType === 'pole') {
      priorityTier = 2; // Poles always appear in 30-70% window (after tier 1 subs/xfmrs)
    } else if (healthScore !== undefined && loadPercent !== undefined) {
      if (healthScore < 50 || loadPercent > 85) priorityTier = 1; // Critical: 0-30%
      else if (healthScore < 70 || loadPercent > 70) priorityTier = 2; // Warning: 30-70%
    } else if (healthScore !== undefined) {
      if (healthScore < 50) priorityTier = 1;
      else if (healthScore < 70) priorityTier = 2;
    }
    
    // Define tier time windows
    const tierStart = priorityTier === 1 ? 0.0 : priorityTier === 2 ? 0.3 : 0.7;
    const tierEnd = priorityTier === 1 ? 0.3 : priorityTier === 2 ? 0.7 : 1.0;
    
    // Simplified positional hash (no sin/cos for performance)
    const hash = ((longitude * 73856093) ^ (latitude * 19349663)) & 0xFFFF;
    const normalized = (hash / 0xFFFF);
    const tierDuration = tierEnd - tierStart;
    const variance = (normalized - 0.5) * 0.1 * tierDuration;
    
    // Map adjusted animation to this tier's window
    if (adjustedBaseAnimation < tierStart) return 0;
    if (adjustedBaseAnimation > tierEnd) return 1;
    
    const tierProgress = (adjustedBaseAnimation - tierStart) / tierDuration;
    const adjustedProgress = Math.max(0, Math.min(1, tierProgress + variance));
    
    // Smoothstep easing
    return adjustedProgress * adjustedProgress * (3 - 2 * adjustedProgress);
  };
  
  // Dynamic height scaling: taller at low zoom (zoomed out), shorter at high zoom (zoomed in)
  // Use linear scaling to avoid drastic jumps
  // REDUCED: 0.2 ‚Üí 0.05 to scale down max column heights (user request: Dec 30, 2025)
  // Dynamic height scaling: use throttledZoom to reduce recalculation frequency
  const heightScale = 1 + Math.max(0, (12 - throttledZoom)) * 0.05;

  const { substationAssets, transformerAssets, poleAssets, meterAssets } = useMemo(() => {
    // Normalize type to lowercase for case-insensitive matching
    const filtered = {
      substationAssets: assets.filter(a => a.type?.toLowerCase() === 'substation'),
      transformerAssets: assets.filter(a => a.type?.toLowerCase() === 'transformer'),
      poleAssets: assets.filter(a => a.type?.toLowerCase() === 'pole'),
      meterAssets: assets.filter(a => a.type?.toLowerCase() === 'meter')
    };
    
    // Debug: Log asset counts only when assets change
    if (assets.length > 0 && filtered.substationAssets.length === 0) {
      console.warn(`‚ö†Ô∏è  Asset type filtering issue: ${assets.length} total assets but 0 substations found`);
      console.warn('Sample asset types:', assets.slice(0, 5).map(a => ({ id: a.id, type: a.type })));
    }
    
    return filtered;
  }, [assets]);

  const unifiedClusters = useMemo(() => {
    // ENGINEERING REDESIGN: Substation-based operational clustering
    // OLD: Arbitrary 0.01-degree grid squares (~1km) - generated unrealistic number of cells
    // NEW: Cluster by substation service areas - aligns with utility operational structure
    // BENEFIT: Matches Daniel Sumners' vision ("Asset 360 & Digital Twin") and Grid 360 competition
    
    return substationBasedClustering(substationAssets, transformerAssets, poleAssets, meterAssets);
  }, [substationAssets, transformerAssets, poleAssets, meterAssets]);

  const flattenedClusterData = useMemo(() => {
    const aggregateTowers: any[] = [];

    // Removed console.log for performance

    unifiedClusters.forEach(cell => {
      if (cell.assets.length === 0) return;

      // ENGINEERING METRICS: Aggregate cell statistics
      const totalAssets = cell.assets.length;
      const substationCount = cell.substations.length;
      const transformerCount = cell.transformers.length;
      const poleCount = cell.poles.length;
      const meterCount = cell.meters.length;

      // Calculate aggregate health (average across all assets with health scores)
      const assetsWithHealth = cell.assets.filter(a => a.health_score != null && a.health_score !== undefined);
      const avgHealth = assetsWithHealth.length > 0
        ? assetsWithHealth.reduce((sum, a) => sum + a.health_score, 0) / assetsWithHealth.length
        : null;

      // Calculate aggregate load (average across transformers)
      const avgLoad = cell.transformers.length > 0
        ? cell.transformers.reduce((sum, t) => sum + (t.load_percent || 50), 0) / cell.transformers.length
        : 50;

      // Engineering: Use average-based assessment for operational status (matches glow logic)
      // This provides balanced view: single outlier doesn't overstate entire cell severity
      let worstStatus: 'critical' | 'warning' | 'good' = 'good';
      let statusColor = [34, 197, 94, 200]; // Green

      // Calculate individual asset health status counts with breakdown by type
      let criticalCount = 0;
      let warningCount = 0;
      let healthyCount = 0;
      
      const healthByType = {
        substations: { critical: 0, warning: 0, healthy: 0 },
        transformers: { critical: 0, warning: 0, healthy: 0 },
        poles: { critical: 0, warning: 0, healthy: 0 },
        meters: { critical: 0, warning: 0, healthy: 0 }
      };
      
      // Store actual assets by health status for expandable lists
      const assetsByHealth = {
        critical: [] as Asset[],
        warning: [] as Asset[],
        healthy: [] as Asset[]
      };
      
      cell.assets.forEach(asset => {
        const health = asset.health_score != null && asset.health_score !== undefined ? asset.health_score : 100;
        const load = asset.load_percent != null && asset.load_percent !== undefined ? asset.load_percent : 0;
        
        let status: 'critical' | 'warning' | 'healthy' = 'healthy';
        if (health < 50 || load > 85) {
          criticalCount++;
          status = 'critical';
          assetsByHealth.critical.push(asset);
        } else if (health < 70 || load > 70) {
          warningCount++;
          status = 'warning';
          assetsByHealth.warning.push(asset);
        } else {
          healthyCount++;
          status = 'healthy';
          assetsByHealth.healthy.push(asset);
        }
        
        // Track by asset type
        const assetType = asset.type?.toLowerCase();
        if (assetType === 'substation') healthByType.substations[status]++;
        else if (assetType === 'transformer') healthByType.transformers[status]++;
        else if (assetType === 'pole') healthByType.poles[status]++;
        else if (assetType === 'meter') healthByType.meters[status]++;
      });

      // Assess status based on average metrics (aligns with glow color)
      // Only consider health if data exists (poles have health sensors, transformers don't)
      if (avgLoad > 85 || (avgHealth !== null && avgHealth < 50)) {
        worstStatus = 'critical';
        statusColor = [239, 68, 68, 200]; // Red
      } else if (avgLoad > 70 || (avgHealth !== null && avgHealth < 70)) {
        worstStatus = 'warning';
        statusColor = [251, 191, 36, 200]; // Yellow
      }

      // TOWER HEIGHT: Prioritize health status, then infrastructure importance
      // Critical (red) cells are tallest, warning (yellow) second tallest, good (green) shortest
      const importanceScore = (substationCount * 3) + (transformerCount * 2) + (poleCount * 1);
      const BASE_HEIGHT = 300;
      const HEIGHT_PER_IMPORTANCE = 50; // Reduced from 75 to allow status to dominate
      const STATUS_HEIGHT_MULTIPLIER = worstStatus === 'critical' ? 2.5 : worstStatus === 'warning' ? 1.75 : 1.0;
      const MAX_HEIGHT = 12000; // Raised to allow status multipliers to show height differences
      const rawHeight = (BASE_HEIGHT + (importanceScore * HEIGHT_PER_IMPORTANCE)) * STATUS_HEIGHT_MULTIPLIER;
      const towerHeight = Math.min(rawHeight, MAX_HEIGHT) * heightScale;

      // TOWER RADIUS: Geographic clustering boundary (actual service territory)
      // ENGINEERING: Calculate radius from actual cell boundary (centroid ‚Üí furthest asset)
      // This represents real-world electrical service area, not arbitrary density scaling
      const cellAssets = [...cell.substations, ...cell.transformers, ...cell.poles, ...cell.meters];
      let maxDistance = 0;
      cellAssets.forEach(asset => {
        const assetLon = 'longitude' in asset ? asset.longitude : asset.coords[0];
        const assetLat = 'latitude' in asset ? asset.latitude : asset.coords[1];
        const dx = (assetLon - cell.centroid[0]) * 111320 * Math.cos(cell.centroid[1] * Math.PI / 180); // meters
        const dy = (assetLat - cell.centroid[1]) * 111320; // meters
        const distance = Math.sqrt(dx * dx + dy * dy);
        maxDistance = Math.max(maxDistance, distance);
      });
      
      // Add 20% buffer for visual clarity + operational boundary
      // Min 60m (single pole), typical 150-400m (neighborhood), max 800m (major substation)
      const towerRadius = Math.max(60, Math.min(800, maxDistance * 1.2));
      
      // Debug logging disabled for performance (was causing 100+ logs per render)
      
      // ENGINEERING: Calculate relative impact score for intelligent glow sizing
      // Higher impact = larger glow radius, communicates operational importance
      const impactScore = importanceScore + (worstStatus === 'critical' ? 10 : worstStatus === 'warning' ? 5 : 0);

      // Single aggregate tower with status color
      // CNP-REALISTIC: Use service district ID or substation name for naming
      const cellId = cell.districtId || (
        cell.substations.length > 0 
          ? cell.substations[0].name  // Use full substation name for non-subdivided territories
          : `Grid Cell ${cell.centroid[0].toFixed(2)}, ${cell.centroid[1].toFixed(2)}`
      );
      
      aggregateTowers.push({
        position: cell.centroid,
        elevation: towerHeight,
        baseZ: 0,
        color: statusColor,
        radius: towerRadius,
        asset: {
          id: cellId,
          name: `Grid Cell: ${totalAssets} assets`,
          type: 'aggregate',
          // Store aggregate metrics for tooltip
          totalAssets,
          substationCount,
          transformerCount,
          poleCount,
          meterCount,
          avgHealth: avgHealth !== null ? Math.round(avgHealth) : null,
          avgLoad: Math.round(avgLoad),
          worstStatus,
          impactScore,
          latitude: cell.centroid[1],
          longitude: cell.centroid[0],
          // #Enhancement: Store health status counts
          criticalCount,
          warningCount,
          healthyCount,
          healthByType, // Breakdown by asset type
          assetsByHealth, // Assets grouped by health status
          // #Enhancement: Store actual assets for detailed drill-down
          substations: cell.substations,
          transformers: cell.transformers,
          poles: cell.poles,
          meters: cell.meters
        }
      });
    });

    // Removed console.log for performance

    return { aggregateTowers };
  }, [unifiedClusters, layersVisible.enable3D, throttledZoom, heightScale]);  // heightScale now based on throttledZoom

  // ENGINEERING METRICS: Calculate real-time operational intelligence from grid state
  // Palantir Grid 360 shows LAGGING indicators (outages after they happen)
  // Snowflake Grid Command shows LEADING indicators (stress BEFORE failure)
  const kpis = useMemo(() => {
    // Calculate from actual grid cell aggregates
    const totalCells = flattenedClusterData.aggregateTowers.length;
    
    if (totalCells === 0) {
      // Fallback to placeholder values during initial load
      return {
        saidi: 152.3,
        saifi: 1.42,
        activeOutages: 8,
        totalLoad: 2847,
        crewsActive: 12,
        assetHealth: 87.3,
        networkReliability: 99.7,
        operationalMargin: 0,
        stressAwareReliability: 0
      };
    }

    // Count cells by operational status
    const criticalCells = flattenedClusterData.aggregateTowers.filter((c: any) => c.asset.worstStatus === 'critical').length;
    const warningCells = flattenedClusterData.aggregateTowers.filter((c: any) => c.asset.worstStatus === 'warning').length;
    const healthyCells = totalCells - criticalCells - warningCells;

    // #METRIC 1: Operational Margin - % of grid NOT under stress
    // This answers: "What percentage of my infrastructure has HEALTHY operating margin?"
    const operationalMargin = ((healthyCells / totalCells) * 100);

    // Calculate system-wide averages from grid cells
    const avgHealth = flattenedClusterData.aggregateTowers.reduce((sum: number, c: any) => sum + c.asset.avgHealth, 0) / totalCells;
    const avgLoad = flattenedClusterData.aggregateTowers.reduce((sum: number, c: any) => sum + c.asset.avgLoad, 0) / totalCells;
    const avgLoadHeadroom = 100 - avgLoad;

    // #METRIC 2: Stress-Aware Reliability - Weighted combination acknowledging degradation
    // Traditional reliability only measures binary outages (up/down)
    // This measures: Health (60% weight) + Available Capacity (40% weight)
    const stressAwareReliability = (avgHealth * 0.6) + (avgLoadHeadroom * 0.4);

    // Traditional utility metrics (for comparison with legacy systems)
    const binaryReliability = ((healthyCells + warningCells) / totalCells) * 100; // Only counts complete failures

    return {
      // Traditional Metrics (what Palantir shows)
      saidi: 152.3,  // System Average Interruption Duration Index
      saifi: 1.42,   // System Average Interruption Frequency Index
      activeOutages: criticalCells,  // Count of cells in critical state
      totalLoad: 2847,
      crewsActive: 12,
      assetHealth: avgHealth,  // Now REAL average from grid cells
      networkReliability: binaryReliability,  // Traditional binary reliability
      
      // ENGINEERING METRICS (competitive advantage)
      operationalMargin: operationalMargin,  // NEW: Leading indicator
      stressAwareReliability: stressAwareReliability  // NEW: Degradation-aware reliability
    };
  }, [flattenedClusterData]);

  // Memoize heatmap data for performance
  const heatmapData = useMemo(() => 
    meterAssets
      .filter(a => a.usage_kwh && a.usage_kwh > 0)
      .map(a => ({
        position: [a.longitude, a.latitude],
        weight: Math.log((a.usage_kwh || 1) + 1) / 4
      })),
    [meterAssets]
  );

  const layers = useMemo(() => [
    // FLUX WEATHER INTELLIGENCE - Broadcast-quality weather visualization
    // Server-rendered smooth gradient image displayed as single texture (GPU-optimized)
    ...(layersVisible.weather && weather.length > 0 ? (() => {
      const currentTemp = weather[weatherTimelineIndex]?.TEMP_F || 75;
      
      // Houston metro bounds for image overlay
      const bounds: [[number, number], [number, number]] = [
        [-96.1, 29.4],  // Southwest corner [lon, lat]
        [-94.9, 30.2]   // Northeast corner [lon, lat]
      ];
      
      // Generate weather image URL with correct aspect ratio for Houston bounds
      // Bounds span 1.2¬∞ lon √ó 0.8¬∞ lat = 1.5:1 ratio ‚Üí use 1536√ó1024 pixels
      const imageUrl = `/api/weather/image?temp_f=${currentTemp}&width=1536&height=1024&t=${weatherTimelineIndex}`;

      return [
        new BitmapLayer({
          id: 'weather-gradient',
          bounds: bounds,
          image: imageUrl,
          opacity: 0.7,
          pickable: false,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          updateTriggers: {
            image: weatherTimelineIndex  // Regenerate image when timeline changes
          }
        })
      ];
    })() : []),

    // Heatmap layer for meter usage density (GPU-optimized)
    ...(layersVisible.heatmap ? [new HeatmapLayer({
      id: 'usage-heatmap',
      data: heatmapData,
      getPosition: (d: any) => d.position,
      getWeight: (d: any) => d.weight,
      radiusPixels: 25,
      intensity: 1.5,
      threshold: 0.02,
      aggregation: 'SUM',
      colorRange: [
        [255, 255, 178, 25],
        [254, 204, 92, 85],
        [253, 141, 60, 170],
        [240, 59, 32, 255],
        [189, 0, 38, 255]
      ]
    })] : []),

    // ZOOM-ADAPTIVE NETWORK TOPOLOGY: Three-tier hierarchical visualization
    // Metro view (<9): Service area polygons | Neighborhood (9-11.5): Distribution feeders | Street (>11.5): Full network
    ...(layersVisible.connections ? (() => {
      const layers: any[] = [];
      
      // METRO VIEW (Zoom < 9): Grid cell hexagonal tiles matching tower operational status
      if (throttledZoom < 9) {
        // Create hexagon tiles directly under each grid cell tower
        const hexagonTileData = flattenedClusterData.aggregateTowers.map((tower: any) => ({
          position: tower.position,
          operationalStatus: tower.asset.worstStatus,
          avgLoad: tower.asset.avgLoad,
          avgHealth: tower.asset.avgHealth,
          cellId: tower.asset.id
        }));
        
        layers.push(new PolygonLayer({
          id: 'grid-cell-hexagon-tiles',
          data: hexagonTileData,
          pickable: true,
          extruded: false,
          filled: true,
          wireframe: false,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          getPolygon: (d: any) => {
            const metersToDegreesLon = 1 / 111320 / Math.cos(29.7604 * Math.PI / 180);
            const metersToDegreesLat = 1 / 110540;
            const radiusMeters = 750; // 750m service radius - reduced by 50%
            const radiusLon = radiusMeters * metersToDegreesLon;
            const radiusLat = radiusMeters * metersToDegreesLat;
            
            const vertices: number[][] = [];
            for (let i = 0; i < 6; i++) {
              const angle = (Math.PI / 3) * i;
              vertices.push([
                d.position[0] + radiusLon * Math.cos(angle),
                d.position[1] + radiusLat * Math.sin(angle)
              ]);
            }
            vertices.push(vertices[0]);
            return vertices;
          },
          getFillColor: (d: any) => {
            // Match grid cell operational color logic
            if (d.operationalStatus === 'critical') return [239, 68, 68, 120];   // Red
            if (d.operationalStatus === 'warning') return [251, 191, 36, 120];   // Yellow
            return [34, 197, 94, 120];                                           // Green
          },
          getLineColor: (d: any) => {
            // Darker outline for clarity
            if (d.operationalStatus === 'critical') return [185, 28, 28, 200];
            if (d.operationalStatus === 'warning') return [217, 119, 6, 200];
            return [21, 128, 61, 200];
          },
          getLineWidth: 2,
          lineWidthUnits: 'pixels',
          opacity: 0.7,
          updateTriggers: {
            getPolygon: flattenedClusterData,
            getFillColor: flattenedClusterData,
            getLineColor: flattenedClusterData
          },
          onClick: (info: any) => {
            if (info.object) {
              console.log('Grid cell operational status:', {
                cellId: info.object.cellId,
                status: info.object.operationalStatus,
                avgLoad: info.object.avgLoad?.toFixed(1),
                avgHealth: info.object.avgHealth?.toFixed(1)
              });
            }
          }
        }));
      }
      
      // NEIGHBORHOOD VIEW (Zoom 9-11.5): Distribution feeders with aggressive performance filtering
      if (throttledZoom >= 9 && throttledZoom < 11.5) {
        // Viewport-based spatial filtering for performance
        const zoom = viewState.zoom;
        const degPerPixel = 360 / (256 * Math.pow(2, zoom));
        const viewWidth = (typeof window !== 'undefined' ? window.innerWidth : 1920) * degPerPixel;
        const viewHeight = (typeof window !== 'undefined' ? window.innerHeight : 1080) * degPerPixel;
        
        const bounds = {
          minLng: viewState.longitude - (viewWidth / 2) * 0.8,
          maxLng: viewState.longitude + (viewWidth / 2) * 0.8,
          minLat: viewState.latitude - (viewHeight / 2) * 0.8,
          maxLat: viewState.latitude + (viewHeight / 2) * 0.8
        };
        
        // Aggressive filtering: viewport + high priority only
        const filteredFeeders = feederTopologyData.filter((d: any) => {
          const load = d.LOAD_UTILIZATION_PCT || 0;
          const kva = d.RATED_KVA || 0;
          const inViewport = (
            (d.FROM_LON >= bounds.minLng && d.FROM_LON <= bounds.maxLng &&
             d.FROM_LAT >= bounds.minLat && d.FROM_LAT <= bounds.maxLat) ||
            (d.TO_LON >= bounds.minLng && d.TO_LON <= bounds.maxLng &&
             d.TO_LAT >= bounds.minLat && d.TO_LAT <= bounds.maxLat)
          );
          // Only show critical/high-priority feeders in viewport
          return inViewport && (load > 70 || kva > 500);
        }).slice(0, 1000);
        
        layers.push(new ArcLayer({
          id: 'distribution-feeders',
          data: filteredFeeders,
          pickable: true,
          widthUnits: 'pixels',
          widthMinPixels: 1,
          widthMaxPixels: 5,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          getSourcePosition: (d: any) => [d.FROM_LON, d.FROM_LAT],
          getTargetPosition: (d: any) => [d.TO_LON, d.TO_LAT],
          getSourceColor: (d: any) => {
            const load = d.LOAD_UTILIZATION_PCT || 0;
            if (load > 90) return [255, 50, 50, 240];
            if (load > 80) return [255, 100, 0, 220];
            if (load > 70) return [255, 165, 0, 200];
            if (load > 60) return [255, 215, 0, 180];
            return [0, 255, 150, 160];
          },
          getTargetColor: (d: any) => {
            const load = d.LOAD_UTILIZATION_PCT || 0;
            const alpha = 0.5;
            if (load > 90) return [255, 50, 50, 240 * alpha];
            if (load > 80) return [255, 100, 0, 220 * alpha];
            if (load > 70) return [255, 165, 0, 200 * alpha];
            if (load > 60) return [255, 215, 0, 180 * alpha];
            return [0, 255, 150, 160 * alpha];
          },
          getWidth: (d: any) => {
            const load = d.LOAD_UTILIZATION_PCT || 0;
            const kva = d.RATED_KVA || 0;
            if (load > 90 || kva > 750) return 4;
            if (load > 80 || kva > 500) return 3;
            if (load > 70 || kva > 350) return 2.5;
            return 2;
          },
          getHeight: (d: any) => {
            const dx = d.TO_LON - d.FROM_LON;
            const dy = d.TO_LAT - d.FROM_LAT;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const load = d.LOAD_UTILIZATION_PCT || 0;
            const priorityMultiplier = load > 80 ? 0.35 : load > 70 ? 0.3 : 0.25;
            return distance * priorityMultiplier;
          },
          getTilt: 0,
          opacity: 0.9,
          updateTriggers: {
            getSourceColor: [feederTopologyData, throttledZoom],
            getTargetColor: [feederTopologyData, throttledZoom],
            getSourcePosition: [feederTopologyData, throttledZoom],
            getTargetPosition: [feederTopologyData, throttledZoom],
            getWidth: [feederTopologyData, throttledZoom],
            getHeight: [feederTopologyData, throttledZoom]
          },
          onClick: (info: any) => {
            if (info.object) {
              console.log('Distribution feeder:', info.object);
            }
          }
        }));
      }
      
      // STREET VIEW (Zoom >= 10): Full service hierarchy with smooth reveal animation
      console.log('[DEBUG] Pre-check: throttledZoom:', throttledZoom, 'layersVisible.connections:', layersVisible.connections, 'topology.length:', topology.length);
      if (throttledZoom >= 10 && visibleTopology.length > 0) {
        console.log('[SERVICE-CONNECTIONS] visibleTopology.length:', visibleTopology.length, 'selectedAsset:', selectedAsset?.id || 'none');
        
        layers.push(new ArcLayer({
            id: 'service-connections',
            data: visibleTopology,
            pickable: false,
            getSourcePosition: (d: TopologyLink) => [d.from_longitude, d.from_latitude],
            getTargetPosition: (d: TopologyLink) => [d.to_longitude, d.to_latitude],
            getSourceColor: (d: TopologyLink) => {
              const isSelected = selectedAsset && 
                (d.from_asset_id === selectedAsset.id || d.to_asset_id === selectedAsset.id);
              
              if (isSelected) {
                return [0, 255, 255, 180];
              }
              
              const zoom = throttledZoom;
              const degPerPixel = 360 / (256 * Math.pow(2, zoom));
              const viewWidth = (typeof window !== 'undefined' ? window.innerWidth : 1920) * degPerPixel;
              const viewHeight = (typeof window !== 'undefined' ? window.innerHeight : 1080) * degPerPixel;
              
              const halfViewWidth = viewWidth / 2;
              const halfViewHeight = viewHeight / 2;
              const centerLng = viewState.longitude;
              const centerLat = viewState.latitude;
              const distFromCenterLng = Math.abs(d.from_longitude - centerLng) / halfViewWidth;
              const distFromCenterLat = Math.abs(d.from_latitude - centerLat) / halfViewHeight;
              const distFromCenter = Math.max(distFromCenterLng, distFromCenterLat);
              
              const fadeFactor = distFromCenter < 0.4 ? 1.0 : Math.max(0.3, 1.0 - (distFromCenter - 0.4) / 0.2);
              
              const status = (d.connection_type || '').toUpperCase();
              const dx = d.to_longitude - d.from_longitude;
              const dy = d.to_latitude - d.from_latitude;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const baseAlpha = distance > 0.01 ? 90 : 110;
              const alpha = Math.round(baseAlpha * fadeFactor);
              
              if (status.includes('FAULT') || status.includes('OUTAGE') || status.includes('CRITICAL') || status.includes('OFFLINE')) {
                return [255, 60, 60, alpha];
              }
              if (status.includes('WARNING') || status.includes('OVERLOAD') || status.includes('HIGH_LOAD') || status.includes('DEGRADED')) {
                return [255, 220, 60, alpha];
              }
              return [50, 255, 100, alpha];
            },
            getTargetColor: (d: TopologyLink) => {
              const isSelected = selectedAsset && 
                (d.from_asset_id === selectedAsset.id || d.to_asset_id === selectedAsset.id);
              
              if (isSelected) {
                return [0, 255, 255, 120];
              }
              
              const zoom = throttledZoom;
              const degPerPixel = 360 / (256 * Math.pow(2, zoom));
              const viewWidth = (typeof window !== 'undefined' ? window.innerWidth : 1920) * degPerPixel;
              const viewHeight = (typeof window !== 'undefined' ? window.innerHeight : 1080) * degPerPixel;
              
              const halfViewWidth = viewWidth / 2;
              const halfViewHeight = viewHeight / 2;
              const centerLng = viewState.longitude;
              const centerLat = viewState.latitude;
              const distFromCenterLng = Math.abs(d.to_longitude - centerLng) / halfViewWidth;
              const distFromCenterLat = Math.abs(d.to_latitude - centerLat) / halfViewHeight;
              const distFromCenter = Math.max(distFromCenterLng, distFromCenterLat);
              
              const fadeFactor = distFromCenter < 0.4 ? 1.0 : Math.max(0.3, 1.0 - (distFromCenter - 0.4) / 0.2);
              
              const status = (d.connection_type || '').toUpperCase();
              const baseAlpha = 60;
              const alpha = Math.round(baseAlpha * fadeFactor);
              
              if (status.includes('FAULT') || status.includes('OUTAGE') || status.includes('CRITICAL') || status.includes('OFFLINE')) {
                return [220, 40, 40, alpha];
              }
              if (status.includes('WARNING') || status.includes('OVERLOAD') || status.includes('HIGH_LOAD') || status.includes('DEGRADED')) {
                return [230, 190, 40, alpha];
              }
              return [40, 220, 80, alpha];
            },
            getHeight: (d: TopologyLink) => {
              const dx = d.to_longitude - d.from_longitude;
              const dy = d.to_latitude - d.from_latitude;
              const distance = Math.sqrt(dx * dx + dy * dy);
              return Math.min(distance * 15, 0.3);
            },
            getTilt: 0,
            getWidth: (d: TopologyLink) => {
              const isSelected = selectedAsset && 
                (d.from_asset_id === selectedAsset.id || d.to_asset_id === selectedAsset.id);
              return isSelected ? 2.0 : 1.2;
            },
            widthUnits: 'pixels',
            widthMinPixels: 0.8,
            widthMaxPixels: 2.5,
            opacity: 0.65,  // Fixed opacity for testing
            updateTriggers: {
              getData: [visibleTopology.length, selectedAsset?.id],
              getSourceColor: selectedAsset?.id,
              getTargetColor: selectedAsset?.id,
              getWidth: selectedAsset?.id,
              getOpacity: throttledZoom
            }
          }));
      }
      
    return layers;
  })() : []),

    // AGGREGATE INFRASTRUCTURE TOWERS - Single unified hexagonal tower per grid cell (LOW ZOOM ONLY)
    // Shows engineering-relevant metrics: height = health status priority, color = worst status, width = density
    ...((layersVisible.substations || layersVisible.transformers || layersVisible.poles) && 
        currentZoom < ZOOM_THRESHOLD ?  // Only show clusters BELOW threshold
      [new PolygonLayer({
        id: 'aggregate-towers',
        data: flattenedClusterData.aggregateTowers,
        pickable: true,
        extruded: true,
        wireframe: true,
        coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
        getPolygon: (d: any) => getHexagonPolygon(d.position[0], d.position[1], d.radius),
        getElevation: (d: any) => {
          const staggeredScale = getStaggerDelay(
            d.position[0], 
            d.position[1], 
            towerScaleAnimation,
            d.asset.avgHealth,
            d.asset.avgLoad
          );
          return d.elevation * staggeredScale;
        },
        getFillColor: (d: any) => {
          const staggeredScale = getStaggerDelay(
            d.position[0], 
            d.position[1], 
            towerScaleAnimation,
            d.asset.avgHealth,
            d.asset.avgLoad
          );
          return [...d.color.slice(0, 3), d.color[3] * staggeredScale];
        },
        getLineColor: (d: any) => {
          const staggeredScale = getStaggerDelay(
            d.position[0], 
            d.position[1], 
            towerScaleAnimation,
            d.asset.avgHealth,
            d.asset.avgLoad
          );
          return [255, 255, 255, 120 * staggeredScale];
        },
        elevationScale: 1,
        lineWidthMinPixels: 2,
        updateTriggers: {
          getPolygon: flattenedClusterData.aggregateTowers,
          getFillColor: [flattenedClusterData.aggregateTowers, towerScaleAnimation],
          getElevation: [flattenedClusterData.aggregateTowers, towerScaleAnimation],
          getLineColor: towerScaleAnimation
        },
        onClick: (info: any) => {
          if (info.object?.asset) {
            setSelectedAsset(info.object.asset);
            setSelectedAssetPosition(null); // Clear stored position for new selection
            setClickPosition({ x: info.x, y: info.y });
          }
        }
      })] : []
    ),

    // INDIVIDUAL ASSETS - Full detail view (HIGH ZOOM ONLY)
    ...(layersVisible.substations && currentZoom >= ZOOM_THRESHOLD - 1.5 ?
      [new PolygonLayer({
        id: 'substations-individual',
        data: substationAssets,
        pickable: true,
        extruded: true,
        wireframe: true,
        coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
        getPolygon: (d: Asset) => getHexagonPolygon(d.longitude, d.latitude, 504),
        getElevation: (d: Asset) => {
          const staggeredScale = getStaggerDelay(d.longitude, d.latitude, assetScaleAnimation, d.health_score);
          return 120 * heightScale * staggeredScale;
        },
        getFillColor: (d: Asset) => {
          const staggeredScale = getStaggerDelay(d.longitude, d.latitude, assetScaleAnimation, d.health_score);
          return [0, 200, 255, 200 * staggeredScale];
        },
        getLineColor: (d: Asset) => {
          const staggeredScale = getStaggerDelay(
            d.longitude, 
            d.latitude, 
            assetScaleAnimation,
            d.health_score,
            undefined,
            'substation'
          );
          return [255, 255, 255, 80 * staggeredScale];
        },
        elevationScale: 1,
        lineWidthMinPixels: 1,
        updateTriggers: {
          getElevation: assetScaleAnimation,
          getFillColor: assetScaleAnimation,
          getLineColor: assetScaleAnimation
        },
        onClick: (info: any) => {
          if (info.object) {
            setSelectedAsset(info.object);
            setSelectedAssetPosition(null);
            setClickPosition({ x: info.x, y: info.y });
          }
        }
      })] : []
    ),

    ...(layersVisible.transformers && currentZoom >= ZOOM_THRESHOLD - 1.5 ?
      [
        // Base transformer body
        new PolygonLayer({
          id: 'transformers-individual',
          data: transformerAssets,
          pickable: true,
          extruded: true,
          wireframe: true,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          getPolygon: (d: Asset) => getRectangularPrism(d.longitude, d.latitude, 120, 80),
          getElevation: (d: Asset) => {
            const staggeredScale = getStaggerDelay(
              d.longitude, 
              d.latitude, 
              assetScaleAnimation,
              d.health_score,
              d.load_percent,
              'transformer'
            );
            return 50 * heightScale * staggeredScale;
          },
          getFillColor: (d: Asset) => {
            const staggeredScale = getStaggerDelay(
              d.longitude, 
              d.latitude, 
              assetScaleAnimation,
              d.health_score,
              d.load_percent,
              'transformer'
            );
            return [236, 72, 153, 200 * staggeredScale];
          },
          getLineColor: (d: Asset) => {
            const staggeredScale = getStaggerDelay(
              d.longitude, 
              d.latitude, 
              assetScaleAnimation,
              d.health_score,
              d.load_percent,
              'transformer'
            );
            return [255, 100, 180, 100 * staggeredScale];
          },
          elevationScale: 1,
          lineWidthMinPixels: 3,
          updateTriggers: {
            getElevation: assetScaleAnimation,
            getFillColor: assetScaleAnimation,
            getLineColor: assetScaleAnimation
          },
          onClick: (info: any) => {
            if (info.object) {
              setSelectedAsset(info.object);
              setSelectedAssetPosition(null);
              setClickPosition({ x: info.x, y: info.y });
            }
          }
        }),
        // Operational status cap (25% size) using PolygonLayer for alignment
        new PolygonLayer({
          id: 'transformers-cap',
          data: transformerAssets,
          extruded: true,
          pickable: false,
          wireframe: true,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          getPolygon: (d: Asset) => {
            // Offset to northeast corner of transformer base
            const metersToDegreesLon = 1 / 111320 / Math.cos(d.latitude * Math.PI / 180);
            const metersToDegreesLat = 1 / 110540;
            const offsetLon = 30 * metersToDegreesLon; // Half of 60m (25% of 120m base width)
            const offsetLat = 20 * metersToDegreesLat; // Half of 40m (25% of 80m base length)
            
            return getRectangularPrism(
              d.longitude + offsetLon,
              d.latitude + offsetLat,
              30, // 25% of new 120m width
              20  // 25% of new 80m length
            );
          },
          getElevation: (d: Asset) => {
            const staggeredScale = getStaggerDelay(
              d.longitude, 
              d.latitude, 
              assetScaleAnimation,
              d.health_score,
              d.load_percent,
              'transformer'
            );
            return 12.5 * heightScale * staggeredScale + 52.5 * heightScale; // 25% cap height + sit on top (105% total)
          },
          getFillColor: (d: Asset) => {
            const staggeredScale = getStaggerDelay(
              d.longitude, 
              d.latitude, 
              assetScaleAnimation,
              d.health_score,
              d.load_percent,
              'transformer'
            );
            
            const health = d.health_score != null ? d.health_score : 100;
            const load = d.load_percent != null ? d.load_percent : 0;
            
            if (load > 85 || health < 50) return [239, 68, 68, 220 * staggeredScale]; // Red
            if (load > 70 || health < 70) return [251, 191, 36, 220 * staggeredScale]; // Yellow
            return [34, 197, 94, 220 * staggeredScale]; // Green
          },
          getLineColor: (d: Asset) => {
            const staggeredScale = getStaggerDelay(
              d.longitude, 
              d.latitude, 
              assetScaleAnimation,
              d.health_score,
              d.load_percent,
              'transformer'
            );
            const health = d.health_score != null ? d.health_score : 100;
            const load = d.load_percent != null ? d.load_percent : 0;
            
            if (load > 85 || health < 50) return [185, 28, 28, 180 * staggeredScale];
            if (load > 70 || health < 70) return [217, 119, 6, 180 * staggeredScale];
            return [21, 128, 61, 180 * staggeredScale];
          },
          elevationScale: 1,
          lineWidthMinPixels: 2,
          updateTriggers: {
            getPolygon: assetScaleAnimation,
            getElevation: assetScaleAnimation,
            getFillColor: assetScaleAnimation,
            getLineColor: assetScaleAnimation
          }
        })
      ] : []
    ),

    ...(layersVisible.poles && currentZoom >= ZOOM_THRESHOLD - 2.0 ?
      [
        // Poles base layer - Primary color (70% of height)
        new ColumnLayer({
          id: 'poles-individual-base',
          data: poleAssets,
          pickable: true,
          extruded: true,
          diskResolution: 8,  // HEAVILY reduced for performance (was 12)
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          getPosition: (d: Asset) => [d.longitude, d.latitude, 0],
          getElevation: (d: Asset) => {
            const staggeredScale = getStaggerDelay(d.longitude, d.latitude, assetScaleAnimation, d.health_score, undefined, 'pole');
            return 40 * heightScale * 0.7 * staggeredScale;  // 50% reduction
          },
          getFillColor: (d: Asset) => {
            const staggeredScale = getStaggerDelay(d.longitude, d.latitude, assetScaleAnimation, d.health_score, undefined, 'pole');
            return [136, 128, 255, 200 * staggeredScale];
          },
          getLineColor: (d: Asset) => {
            const staggeredScale = getStaggerDelay(d.longitude, d.latitude, assetScaleAnimation, d.health_score, undefined, 'pole');
            return [255, 140, 60, 100 * staggeredScale];
          },
          radius: 12.5,  // 75% total reduction
          updateTriggers: {
            getElevation: assetScaleAnimation,
            getFillColor: assetScaleAnimation,
            getLineColor: assetScaleAnimation
          },
          onClick: (info: any) => {
          if (info.object) {
            setSelectedAsset(info.object);
            setSelectedAssetPosition(null);
            setClickPosition({ x: info.x, y: info.y });
          }
        }
        }),
        // Poles status layer - Health-based color (renders on top as second pass)
        new ColumnLayer({
          id: 'poles-individual-status',
          data: poleAssets,
          pickable: true,
          extruded: true,
          diskResolution: 8,  // HEAVILY reduced for performance (was 12)
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          getPosition: (d: Asset) => [d.longitude, d.latitude, 0],  // Start at base
          getElevation: (d: Asset) => {
            const staggeredScale = getStaggerDelay(d.longitude, d.latitude, assetScaleAnimation, d.health_score, undefined, 'pole');
            return 40 * heightScale * staggeredScale;  // 50% reduction
          },
          getFillColor: (d: Asset) => {
            const health = d.health_score !== undefined ? d.health_score : 75;
            const staggeredScale = getStaggerDelay(d.longitude, d.latitude, assetScaleAnimation, d.health_score, undefined, 'pole');
            const alpha = 200 * staggeredScale;
            // Health-based status colors
            if (d.status && (d.status.includes('Poor') || d.status.includes('Critical'))) {
              return [239, 68, 68, alpha]; // Red for Poor/Critical
            }
            if (d.status && d.status.includes('Fair')) {
              return [251, 191, 36, alpha]; // Yellow/Orange for Fair
            }
            // Fallback to health score
            if (health < 60) return [239, 68, 68, alpha];  // Red
            if (health < 80) return [251, 191, 36, alpha];  // Yellow
            return [34, 197, 94, alpha];  // Green
          },
          getLineColor: (d: Asset) => {
            const staggeredScale = getStaggerDelay(d.longitude, d.latitude, assetScaleAnimation, d.health_score, undefined, 'pole');
            return [255, 255, 255, 60 * staggeredScale];
          },
          radius: 10,  // 75% total reduction - slightly smaller than base (12.5)
          updateTriggers: {
            getElevation: assetScaleAnimation,
            getPosition: assetScaleAnimation,
            getFillColor: assetScaleAnimation,
            getLineColor: assetScaleAnimation
          },
          onClick: (info: any) => {
          if (info.object) {
            setSelectedAsset(info.object);
            setSelectedAssetPosition(null);
            setClickPosition({ x: info.x, y: info.y });
          }
        }
        })
      ] : []
    ),



    // Meters (tiny, purple - optimized with memoized data)
    // ZOOM-BASED VISIBILITY: Show individual meters only when zoomed in (Google Maps pattern)
    // At operational view (zoomed out), meters appear only as cluster aggregates
    // At field view (zoomed in), individual meters visible for inspection
    // EMERGENCE: Meters appear LAST - delayed start + slowest emergence
    layersVisible.meters && viewState.zoom > 12 && new ScatterplotLayer({
      id: 'meters',
      data: meterAssets,
      pickable: true,
      opacity: 1.0, // Full opacity - controlled by fill color alpha
      stroked: true,
      filled: true,
      radiusScale: 4,
      radiusMinPixels: 2,
      radiusMaxPixels: 8,
      lineWidthMinPixels: 1,
      coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
      getPosition: (d: Asset) => [d.longitude, d.latitude],
      getRadius: (d: Asset) => {
        // Size variation based on health (poor health = larger/more visible)
        const health = d.health_score !== undefined ? d.health_score : 75;
        const baseSize = 3 + ((d.usage_kwh || 0) / 50) * 4;
        const healthMultiplier = health < 50 ? 1.4 : health < 70 ? 1.2 : 1.0;
        
        // DELAYED START: Meters don't appear until 80% of zoom animation
        const delayThreshold = 0.8;
        if (assetScaleAnimation < delayThreshold) return 0; // Invisible
        
        const remappedAnimation = (assetScaleAnimation - delayThreshold) / (1 - delayThreshold);
        const meterSlowdown = Math.pow(remappedAnimation, 4.5); // 4.5x slower - very gradual
        return baseSize * healthMultiplier * meterSlowdown;
      },
      getFillColor: (d: Asset) => {
        // Opacity variation based on health with very slow emergence
        const delayThreshold = 0.8;
        if (assetScaleAnimation < delayThreshold) return [0, 0, 0, 0]; // Invisible
        
        const remappedAnimation = (assetScaleAnimation - delayThreshold) / (1 - delayThreshold);
        const meterSlowdown = Math.pow(remappedAnimation, 4.5); // 4.5x slower
        const health = d.health_score !== undefined ? d.health_score : 75;
        
        const baseAlpha = health < 50 ? 255 : health < 70 ? 220 : 180;
        return [147, 51, 234, baseAlpha * meterSlowdown];
      },
      getLineColor: (d: Asset) => {
        // Stroke color indicates health level with very slow emergence
        const delayThreshold = 0.8;
        if (assetScaleAnimation < delayThreshold) return [0, 0, 0, 0]; // Invisible
        
        const remappedAnimation = (assetScaleAnimation - delayThreshold) / (1 - delayThreshold);
        const meterSlowdown = Math.pow(remappedAnimation, 4.5); // 4.5x slower
        const health = d.health_score !== undefined ? d.health_score : 75;
        
        if (health < 50) return [239, 68, 68, 255 * meterSlowdown];  // Red outline (poor health)
        if (health < 70) return [251, 191, 36, 255 * meterSlowdown];  // Yellow outline (fair health)
        return [34, 197, 94, 255 * meterSlowdown];  // Green outline (good health)
      },
      updateTriggers: {
        getPosition: meterAssets,
        getRadius: [meterAssets, assetScaleAnimation],
        getFillColor: assetScaleAnimation,
        getLineColor: assetScaleAnimation
      },
      onClick: (info) => {
        if (info.object) {
          setSelectedAsset(info.object);
          setSelectedAssetPosition(null);
          setClickPosition({ x: info.x, y: info.y });
        }
      }
    }),

    // ENGINEERING SELECTION - Impact-aware, category-specific bloom for aggregate towers
    ...(selectedAsset && selectedAsset.type === 'aggregate' ? (() => {
      const glow = getGlowProperties(selectedAsset);
      
      // Calculate impact-based scale multiplier (1.0 to 2.0)
      const maxImpact = 30; // Max expected impact score
      const impactScale = 1.0 + (Math.min(selectedAsset.impactScore || 0, maxImpact) / maxImpact);
      
      // Calculate category-specific health colors
      const getHealthColor = (assets: any[], type: string) => {
        if (!assets || assets.length === 0) return [100, 100, 100]; // Gray for missing
        
        // Filter for valid health scores only
        const withHealth = assets.filter(a => a.health_score != null && a.health_score !== undefined);
        const avgHealth = withHealth.length > 0
          ? withHealth.reduce((sum, a) => sum + a.health_score, 0) / withHealth.length
          : 75; // Default if no health data
        
        const avgLoad = type === 'transformer' 
          ? assets.reduce((sum, a) => sum + (a.load_percent || 50), 0) / assets.length 
          : 0;
        
        // Priority: Load issues > Health issues
        if (type === 'transformer' && avgLoad > 85) return [239, 68, 68]; // Red - overload
        if (avgHealth < 50 || avgLoad > 85) return [239, 68, 68]; // Red - critical
        if (avgHealth < 70 || avgLoad > 70) return [251, 191, 36]; // Amber - warning
        return [34, 197, 94]; // Green - healthy
      };
      
      const substationColor = getHealthColor(selectedAsset.substations, 'substation');
      const transformerColor = getHealthColor(selectedAsset.transformers, 'transformer');
      const poleColor = getHealthColor(selectedAsset.poles, 'pole');
      
      return [
        // Outer ring: Substations (cyan base, health-colored)
        new ScatterplotLayer({
          id: 'aggregate-glow-substations',
          data: [{ position: [selectedAsset.longitude, selectedAsset.latitude, 10] }],
          pickable: false,
          stroked: false,
          filled: true,
          radiusScale: 1,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          radiusMinPixels: (100 + Math.sin(animationFrame * glow.pulseSpeed) * 18 * glow.pulseAmplitude) * glow.glowScale * impactScale * (selectedAsset.substationCount > 0 ? 1.0 : 0.5),
          radiusMaxPixels: 250,
          getPosition: (d: any) => d.position,
          getFillColor: [...substationColor, 30 + Math.sin(animationFrame * glow.pulseSpeed) * 12 * glow.pulseAmplitude],
          updateTriggers: {
            radiusMinPixels: animationFrame,
            getFillColor: animationFrame
          }
        }),
        // Middle ring: Transformers (magenta base, health+load colored)
        new ScatterplotLayer({
          id: 'aggregate-glow-transformers',
          data: [{ position: [selectedAsset.longitude, selectedAsset.latitude, 15] }],
          pickable: false,
          stroked: false,
          filled: true,
          radiusScale: 1,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          radiusMinPixels: (65 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 12 * glow.pulseAmplitude) * glow.glowScale * impactScale * (selectedAsset.transformerCount > 0 ? 1.0 : 0.5),
          radiusMaxPixels: 150,
          getPosition: (d: any) => d.position,
          getFillColor: [...transformerColor, 60 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 25 * glow.pulseAmplitude],
          updateTriggers: {
            radiusMinPixels: animationFrame,
            getFillColor: animationFrame
          }
        }),
        // Inner ring: Poles (purple base, health colored)
        new ScatterplotLayer({
          id: 'aggregate-glow-poles',
          data: [{ position: [selectedAsset.longitude, selectedAsset.latitude, 20] }],
          pickable: false,
          stroked: true,
          filled: true,
          radiusScale: 1,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          radiusMinPixels: (35 + Math.sin(animationFrame * (glow.pulseSpeed + 0.04)) * 8 * glow.pulseAmplitude) * glow.glowScale * impactScale * (selectedAsset.poleCount > 0 ? 1.0 : 0.5),
          radiusMaxPixels: 90,
          lineWidthMinPixels: 2 * glow.strokeIntensity,
          getPosition: (d: any) => d.position,
          getFillColor: [...poleColor, 80 + Math.sin(animationFrame * (glow.pulseSpeed + 0.04)) * 30 * glow.pulseAmplitude],
          getLineColor: [...poleColor.map(c => Math.min(255, c + 50)), 180 + Math.sin(animationFrame * (glow.pulseSpeed + 0.04)) * 75 * glow.strokeIntensity],
          updateTriggers: {
            radiusMinPixels: animationFrame,
            getFillColor: animationFrame,
            getLineColor: animationFrame
          }
        })
      ];
    })() : []),

    // ENGINEERING SELECTION - Priority-based bloom for substations
    ...(selectedAsset && selectedAsset.type === 'substation' ? (() => {
      const glow = getGlowProperties(selectedAsset);
      return [
        // Outer glow
        new ScatterplotLayer({
          id: 'substation-glow-outer',
          data: [{ position: [selectedAsset.longitude, selectedAsset.latitude, 10] }],
          pickable: false,
          stroked: false,
          filled: true,
          radiusScale: 1,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          radiusMinPixels: (35 + Math.sin(animationFrame * glow.pulseSpeed) * 8 * glow.pulseAmplitude) * glow.glowScale,
          radiusMaxPixels: 90,
          getPosition: (d: any) => d.position,
          getFillColor: [...glow.baseColor, 30 + Math.sin(animationFrame * glow.pulseSpeed) * 12 * glow.pulseAmplitude],
          updateTriggers: {
            radiusMinPixels: animationFrame,
            getFillColor: animationFrame
          }
        }),
        // Inner glow
        new ScatterplotLayer({
          id: 'substation-glow-inner',
          data: [{ position: [selectedAsset.longitude, selectedAsset.latitude, 15] }],
          pickable: false,
          stroked: true,
          filled: true,
          radiusScale: 1,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          radiusMinPixels: (18 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 5 * glow.pulseAmplitude) * glow.glowScale,
          radiusMaxPixels: 50,
          lineWidthMinPixels: 2 * glow.strokeIntensity,
          getPosition: (d: any) => d.position,
          getFillColor: [...glow.baseColor.map(c => Math.min(255, c + 20)), 80 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 25 * glow.pulseAmplitude],
          getLineColor: [...glow.baseColor.map(c => Math.min(255, c + 35)), 160 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 60 * glow.strokeIntensity],
          updateTriggers: {
            radiusMinPixels: animationFrame,
            getFillColor: animationFrame,
            getLineColor: animationFrame
          }
        })
      ];
    })() : []),

    // ENGINEERING SELECTION - Priority-based bloom for transformers
    ...(selectedAsset && selectedAsset.type === 'transformer' ? (() => {
      const glow = getGlowProperties(selectedAsset);
      return [
        // Outer glow
        new ScatterplotLayer({
          id: 'transformer-glow-outer',
          data: [{ position: [selectedAsset.longitude, selectedAsset.latitude, 10] }],
          pickable: false,
          stroked: false,
          filled: true,
          radiusScale: 1,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          radiusMinPixels: (28 + Math.sin(animationFrame * glow.pulseSpeed) * 6 * glow.pulseAmplitude) * glow.glowScale,
          radiusMaxPixels: 70,
          getPosition: (d: any) => d.position,
          getFillColor: [...glow.baseColor, 35 + Math.sin(animationFrame * glow.pulseSpeed) * 15 * glow.pulseAmplitude],
          updateTriggers: {
            radiusMinPixels: animationFrame,
            getFillColor: animationFrame
          }
        }),
        // Inner glow
        new ScatterplotLayer({
          id: 'transformer-glow-inner',
          data: [{ position: [selectedAsset.longitude, selectedAsset.latitude, 15] }],
          pickable: false,
          stroked: true,
          filled: true,
          radiusScale: 1,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          radiusMinPixels: (14 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 4 * glow.pulseAmplitude) * glow.glowScale,
          radiusMaxPixels: 40,
          lineWidthMinPixels: 2 * glow.strokeIntensity,
          getPosition: (d: any) => d.position,
          getFillColor: [...glow.baseColor.map(c => Math.min(255, c + 20)), 90 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 30 * glow.pulseAmplitude],
          getLineColor: [...glow.baseColor.map(c => Math.min(255, c + 35)), 170 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 65 * glow.strokeIntensity],
        updateTriggers: {
          radiusMinPixels: animationFrame,
          getFillColor: animationFrame,
          getLineColor: animationFrame
        }
      })
      ];
    })() : []),

    // ENGINEERING SELECTION - Priority-based bloom for poles
    ...(selectedAsset && selectedAsset.type === 'pole' ? (() => {
      const glow = getGlowProperties(selectedAsset);
      return [
        // Outer glow
        new ScatterplotLayer({
          id: 'pole-glow-outer',
          data: [{ position: [selectedAsset.longitude, selectedAsset.latitude, 10] }],
          pickable: false,
          stroked: false,
          filled: true,
          radiusScale: 1,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          radiusMinPixels: (22 + Math.sin(animationFrame * glow.pulseSpeed) * 5 * glow.pulseAmplitude) * glow.glowScale,
          radiusMaxPixels: 55,
          getPosition: (d: any) => d.position,
          getFillColor: [...glow.baseColor, 40 + Math.sin(animationFrame * glow.pulseSpeed) * 18 * glow.pulseAmplitude],
          updateTriggers: {
            radiusMinPixels: animationFrame,
            getFillColor: animationFrame
          }
        }),
        // Inner glow
        new ScatterplotLayer({
          id: 'pole-glow-inner',
          data: [{ position: [selectedAsset.longitude, selectedAsset.latitude, 15] }],
          pickable: false,
          stroked: true,
          filled: true,
          radiusScale: 1,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          radiusMinPixels: (10 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 3 * glow.pulseAmplitude) * glow.glowScale,
          radiusMaxPixels: 30,
          lineWidthMinPixels: 2 * glow.strokeIntensity,
          getPosition: (d: any) => d.position,
          getFillColor: [...glow.baseColor.map(c => Math.min(255, c + 20)), 100 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 35 * glow.pulseAmplitude],
          getLineColor: [...glow.baseColor.map(c => Math.min(255, c + 35)), 180 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 70 * glow.strokeIntensity],
          updateTriggers: {
            radiusMinPixels: animationFrame,
            getFillColor: animationFrame,
            getLineColor: animationFrame
          }
        })
      ];
    })() : []),

    // ENGINEERING SELECTION - Priority-based bloom for meters
    ...(selectedAsset && selectedAsset.type === 'meter' ? (() => {
      const glow = getGlowProperties(selectedAsset);
      return [
        // Outer glow
        new ScatterplotLayer({
          id: 'meter-glow-outer',
          data: [{ position: [selectedAsset.longitude, selectedAsset.latitude, 10] }],
          pickable: false,
          stroked: false,
          filled: true,
          radiusScale: 1,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          radiusMinPixels: (18 + Math.sin(animationFrame * glow.pulseSpeed) * 4 * glow.pulseAmplitude) * glow.glowScale,
          radiusMaxPixels: 45,
          getPosition: (d: any) => d.position,
          getFillColor: [...glow.baseColor, 45 + Math.sin(animationFrame * glow.pulseSpeed) * 20 * glow.pulseAmplitude],
          updateTriggers: {
            radiusMinPixels: animationFrame,
            getFillColor: animationFrame
          }
        }),
        // Inner glow
        new ScatterplotLayer({
          id: 'meter-glow-inner',
          data: [{ position: [selectedAsset.longitude, selectedAsset.latitude, 15] }],
          pickable: false,
          stroked: true,
          filled: true,
          radiusScale: 1,
          coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
          radiusMinPixels: (8 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 2 * glow.pulseAmplitude) * glow.glowScale,
          radiusMaxPixels: 25,
          lineWidthMinPixels: 2 * glow.strokeIntensity,
          getPosition: (d: any) => d.position,
          getFillColor: [...glow.baseColor.map(c => Math.min(255, c + 20)), 110 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 40 * glow.pulseAmplitude],
          getLineColor: [...glow.baseColor.map(c => Math.min(255, c + 35)), 190 + Math.sin(animationFrame * (glow.pulseSpeed + 0.02)) * 65 * glow.strokeIntensity],
          updateTriggers: {
            radiusMinPixels: animationFrame,
            getFillColor: animationFrame,
            getLineColor: animationFrame
          }
        })
      ];
    })() : [])
  ].filter(Boolean), [
    layersVisible,
    useClusteredView,
    weather,
    weatherTimelineIndex,
    meterAssets,
    topology,
    flattenedClusterData,
    substationAssets,
    transformerAssets,
    poleAssets,
    selectedAsset,
    animationFrame,
    throttledZoom,  // Use throttledZoom to reduce expensive layer recreation
    assetScaleAnimation,  // But include assetScaleAnimation for smooth stagger reveals
    towerScaleAnimation   // And towerScaleAnimation for cluster animations
  ]);

  // Removed expensive console.log for performance

  const assetCounts = {
    total: assets.length,
    substations: assets.filter(a => a.type === 'substation').length,
    transformers: assets.filter(a => a.type === 'transformer').length,
    poles: assets.filter(a => a.type === 'pole').length,
    meters: assets.filter(a => a.type === 'meter').length
  };

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', overflow: 'hidden' }}>
        {/* Header */}
        <AppBar position="static" sx={{ bgcolor: '#0d1117', borderBottom: 'none' }}>
          <Toolbar sx={{ justifyContent: 'space-between' }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
              <img 
                src="/flux-logo.png" 
                alt="Flux" 
                className={isLoadingData ? 'flux-spinner' : ''}
                style={{ width: 48, height: 48, objectFit: 'contain', transition: 'width 0.3s, height 0.3s' }}
              />
              <Box>
                <Typography 
                  variant="h5" 
                  className="flux-gradient-text"
                  sx={{ 
                    fontWeight: 100, 
                    fontFamily: '"Quantico", sans-serif',
                    letterSpacing: '0.166em',
                    fontSize: '32px'
                  }}
                >
                  FLUX OPERATIONS CENTER
                </Typography>
                <Typography 
                  variant="caption" 
                  sx={{ 
                    fontFamily: '"Space Mono", monospace',
                    fontWeight: 400,
                    letterSpacing: '0.1em',
                    textTransform: 'uppercase',
                    display: 'block',
                    mt: -1
                  }}
                >
                  <Box component="span" sx={{ color: '#29B5E8' }}>Grid Operations</Box>
                  <Box component="span" sx={{ color: '#6b7280', mx: 1 }}>‚Ä¢</Box>
                  <Box component="span" sx={{ color: '#06B6D4' }}>Houston TX</Box>
                  <Box component="span" sx={{ color: '#6b7280', mx: 1 }}>‚Ä¢</Box>
                  <Box component="span" sx={{ color: '#0EA5E9' }}>Grid Intelligence</Box>
                </Typography>
              </Box>
            </Box>
            <Stack direction="row" spacing={2} alignItems="center">
              <Chip 
                icon={<Speed sx={{ fontSize: 16 }} />} 
                label={`${assetCounts.total.toLocaleString()} Assets`} 
                size="small" 
                sx={{ fontWeight: 600 }}
              />
            </Stack>
          </Toolbar>
          <Tabs value={currentTab} onChange={(_, v) => setCurrentTab(v)} sx={{ bgcolor: '#1a1f2e', borderTop: '1px solid rgba(59, 130, 246, 0.2)' }}>
            <Tab label="Operations Dashboard" />
            <Tab label="Network Topology" />
            <Tab label="Asset Health" />
            <Tab label="AMI Analytics" />
            <Tab label="Outage Management" />
          </Tabs>
        </AppBar>

        {/* Main Content */}
        <Box sx={{ flexGrow: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
          {currentTab === 0 && (
            <>
              {/* Map with Floating KPI Overlays */}
              <Box 
                sx={{ flexGrow: 1, position: 'relative', bgcolor: 'background.paper', overflow: 'hidden' }}
                onContextMenu={(e) => e.preventDefault()}
              >
                {/* Floating KPI Cards - Translucent Overlay */}
                <Box sx={{ 
                  position: 'absolute', 
                  top: 12, 
                  left: 12, 
                  right: 12, 
                  zIndex: 10,
                  display: 'flex',
                  gap: 1,
                  flexWrap: 'wrap',
                  pointerEvents: 'none'
                }}>
                  <Box sx={{ flex: '1 1 auto', minWidth: 120, maxWidth: 160, pointerEvents: 'auto' }}>
                    <KPICard 
                      title="SAIDI" 
                      value={kpis.saidi.toFixed(1)} 
                      subtitle="Minutes" 
                      icon={<Assessment />} 
                      color="#0EA5E9" 
                      trend={-5.2}
                      sx={{ bgcolor: 'rgba(15, 23, 42, 0.65)', backdropFilter: 'blur(16px)', border: '1px solid rgba(255,255,255,0.08)' }}
                    />
                  </Box>
                  <Box sx={{ flex: '1 1 auto', minWidth: 120, maxWidth: 160, pointerEvents: 'auto' }}>
                    <KPICard 
                      title="SAIFI" 
                      value={kpis.saifi.toFixed(2)} 
                      subtitle="Interruptions" 
                      icon={<TrendingUp />} 
                      color="#FBBF24" 
                      trend={-2.1}
                      sx={{ bgcolor: 'rgba(15, 23, 42, 0.65)', backdropFilter: 'blur(16px)', border: '1px solid rgba(255,255,255,0.08)' }}
                    />
                  </Box>
                  <Box sx={{ flex: '1 1 auto', minWidth: 120, maxWidth: 160, pointerEvents: 'auto' }}>
                    <KPICard 
                      title="Active Outages" 
                      value={kpis.activeOutages} 
                      subtitle="Critical Cells" 
                      icon={<Warning />} 
                      color="#EF4444"
                      sx={{ bgcolor: 'rgba(15, 23, 42, 0.65)', backdropFilter: 'blur(16px)', border: '1px solid rgba(255,255,255,0.08)' }}
                    />
                  </Box>
                  <Box sx={{ flex: '1 1 auto', minWidth: 120, maxWidth: 160, pointerEvents: 'auto' }}>
                    <KPICard 
                      title="Asset Health" 
                      value={`${kpis.assetHealth.toFixed(1)}%`} 
                      subtitle="Avg Score" 
                      icon={<Memory />} 
                      color="#10B981"
                      sx={{ bgcolor: 'rgba(15, 23, 42, 0.65)', backdropFilter: 'blur(16px)', border: '1px solid rgba(255,255,255,0.08)' }}
                    />
                  </Box>
                  <Box sx={{ flex: '1 1 auto', minWidth: 140, maxWidth: 180, pointerEvents: 'auto' }}>
                    <KPICard 
                      title="Operational Margin" 
                      value={`${kpis.operationalMargin.toFixed(1)}%`} 
                      subtitle="Healthy Capacity" 
                      icon={<NetworkCheck />} 
                      color={kpis.operationalMargin > 70 ? '#22C55E' : kpis.operationalMargin > 50 ? '#FBBF24' : '#EF4444'}
                      sx={{ bgcolor: 'rgba(15, 23, 42, 0.65)', backdropFilter: 'blur(16px)', border: '1px solid rgba(255,255,255,0.08)' }}
                    />
                  </Box>
                  <Box sx={{ flex: '1 1 auto', minWidth: 140, maxWidth: 180, pointerEvents: 'auto' }}>
                    <KPICard 
                      title="Stress-Aware Reliability" 
                      value={`${kpis.stressAwareReliability.toFixed(1)}%`} 
                      subtitle="Health + Headroom" 
                      icon={<Assessment />} 
                      color={kpis.stressAwareReliability > 75 ? '#06B6D4' : kpis.stressAwareReliability > 60 ? '#FBBF24' : '#EF4444'}
                      sx={{ bgcolor: 'rgba(15, 23, 42, 0.65)', backdropFilter: 'blur(16px)', border: '1px solid rgba(255,255,255,0.08)' }}
                    />
                  </Box>
                </Box>

                {/* Layer Toggle Buttons - Top Right */}
                <Box sx={{ 
                  position: 'absolute', 
                  top: 12, 
                  right: 12, 
                  zIndex: 10,
                  display: 'flex',
                  flexDirection: 'column',
                  gap: 0.5,
                  pointerEvents: 'auto'
                }}>
                  <Paper sx={{ 
                    bgcolor: 'rgba(15, 23, 42, 0.35)', 
                    backdropFilter: 'blur(16px)', 
                    border: '1px solid rgba(255,255,255,0.08)',
                    p: 1.5,
                    minWidth: 160,
                    maxHeight: '80vh',
                    overflowY: 'auto'
                  }}>
                    <Stack spacing={0.5}>
                      {/* Expandable Header */}
                      <Box 
                        sx={{ 
                          display: 'flex', 
                          alignItems: 'center', 
                          justifyContent: 'space-between',
                          cursor: 'pointer',
                          px: 0.5,
                          py: 0.25,
                          borderRadius: 1,
                          '&:hover': { bgcolor: 'rgba(255,255,255,0.05)' }
                        }}
                        onClick={() => setLayersPanelExpanded(!layersPanelExpanded)}
                      >
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                          <Layers sx={{ fontSize: 18, color: 'text.secondary' }} />
                          <Typography variant="caption" sx={{ color: 'text.secondary', fontWeight: 600 }}>
                            LAYERS
                          </Typography>
                        </Box>
                        <IconButton size="small" sx={{ p: 0 }}>
                          {layersPanelExpanded ? <ExpandLess sx={{ fontSize: 16 }} /> : <ExpandMore sx={{ fontSize: 16 }} />}
                        </IconButton>
                      </Box>
                      
                      <Collapse in={layersPanelExpanded}>
                        <Stack spacing={0.5}>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, py: 0.5 }}>
                        <IconButton 
                          size="small"
                          onClick={() => setLayersVisible({...layersVisible, substations: !layersVisible.substations})}
                          sx={{ 
                            color: layersVisible.substations ? '#00C8FF' : 'rgba(255,255,255,0.3)',
                            '&:hover': { bgcolor: 'rgba(0, 200, 255, 0.1)' }
                          }}
                        >
                          <ElectricBolt sx={{ fontSize: 18 }} />
                        </IconButton>
                        <Box sx={{ flex: 1 }}>
                          <Typography variant="caption" sx={{ color: layersVisible.substations ? '#00C8FF' : 'rgba(255,255,255,0.5)', display: 'block', lineHeight: 1.2 }}>
                            Substations
                          </Typography>
                          <Typography variant="caption" sx={{ color: 'text.disabled', fontSize: 9, display: 'block', mt: 0.25 }}>
                            {assetCounts.substations.toLocaleString()} assets
                          </Typography>
                        </Box>
                      </Box>

                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, py: 0.5 }}>
                        <IconButton 
                          size="small"
                          onClick={() => setLayersVisible({...layersVisible, transformers: !layersVisible.transformers})}
                          sx={{ 
                            color: layersVisible.transformers ? '#EC4899' : 'rgba(255,255,255,0.3)',
                            '&:hover': { bgcolor: 'rgba(236, 72, 153, 0.1)' }
                          }}
                        >
                          <Power sx={{ fontSize: 18 }} />
                        </IconButton>
                        <Box sx={{ flex: 1 }}>
                          <Typography variant="caption" sx={{ color: layersVisible.transformers ? '#EC4899' : 'rgba(255,255,255,0.5)', display: 'block', lineHeight: 1.2 }}>
                            Transformers
                          </Typography>
                          <Typography variant="caption" sx={{ color: 'text.disabled', fontSize: 9, display: 'block', mt: 0.25 }}>
                            {assetCounts.transformers.toLocaleString()} assets
                          </Typography>
                        </Box>
                      </Box>

                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, py: 0.5 }}>
                        <IconButton 
                          size="small"
                          onClick={() => setLayersVisible({...layersVisible, poles: !layersVisible.poles})}
                          sx={{ 
                            color: layersVisible.poles ? '#8880ff' : 'rgba(255,255,255,0.3)',
                            '&:hover': { bgcolor: 'rgba(136, 128, 255, 0.1)' }
                          }}
                        >
                          <Engineering sx={{ fontSize: 18 }} />
                        </IconButton>
                        <Box sx={{ flex: 1 }}>
                          <Typography variant="caption" sx={{ color: layersVisible.poles ? '#8880ff' : 'rgba(255,255,255,0.5)', display: 'block', lineHeight: 1.2 }}>
                            Poles
                          </Typography>
                          <Typography variant="caption" sx={{ color: 'text.disabled', fontSize: 9, display: 'block', mt: 0.25 }}>
                            {assetCounts.poles.toLocaleString()} assets
                          </Typography>
                        </Box>
                      </Box>

                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, py: 0.5 }}>
                        <IconButton 
                          size="small"
                          onClick={() => setLayersVisible({...layersVisible, meters: !layersVisible.meters})}
                          sx={{ 
                            color: layersVisible.meters ? '#9333EA' : 'rgba(255,255,255,0.3)',
                            '&:hover': { bgcolor: 'rgba(147, 51, 234, 0.1)' }
                          }}
                        >
                          <Speed sx={{ fontSize: 18 }} />
                        </IconButton>
                        <Box sx={{ flex: 1 }}>
                          <Typography variant="caption" sx={{ color: layersVisible.meters ? '#9333EA' : 'rgba(255,255,255,0.5)', display: 'block', lineHeight: 1.2 }}>
                            Meters
                          </Typography>
                          <Typography variant="caption" sx={{ color: 'text.disabled', fontSize: 9, display: 'block', mt: 0.25 }}>
                            {assetCounts.meters.toLocaleString()} assets
                          </Typography>
                        </Box>
                      </Box>

                      <Divider sx={{ my: 0.5, borderColor: 'rgba(255,255,255,0.08)' }} />

                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <IconButton 
                          size="small"
                          onClick={() => setLayersVisible({...layersVisible, connections: !layersVisible.connections})}
                          sx={{ 
                            color: layersVisible.connections ? '#10B981' : 'rgba(255,255,255,0.3)',
                            '&:hover': { bgcolor: 'rgba(16, 185, 129, 0.1)' }
                          }}
                        >
                          <NetworkCheck sx={{ fontSize: 18 }} />
                        </IconButton>
                        <Typography variant="caption" sx={{ color: layersVisible.connections ? '#10B981' : 'rgba(255,255,255,0.5)', minWidth: 80 }}>
                          Connections
                        </Typography>
                      </Box>

                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <IconButton 
                          size="small"
                          onClick={() => setLayersVisible({...layersVisible, heatmap: !layersVisible.heatmap})}
                          sx={{ 
                            color: layersVisible.heatmap ? '#F59E0B' : 'rgba(255,255,255,0.3)',
                            '&:hover': { bgcolor: 'rgba(245, 158, 11, 0.1)' }
                          }}
                        >
                          <Whatshot sx={{ fontSize: 18 }} />
                        </IconButton>
                        <Typography variant="caption" sx={{ color: layersVisible.heatmap ? '#F59E0B' : 'rgba(255,255,255,0.5)', minWidth: 80 }}>
                          Heatmap
                        </Typography>
                      </Box>

                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <IconButton 
                          size="small"
                          onClick={() => setLayersVisible({...layersVisible, weather: !layersVisible.weather})}
                          sx={{ 
                            color: layersVisible.weather ? '#10B981' : 'rgba(255,255,255,0.3)',
                            '&:hover': { bgcolor: 'rgba(16, 185, 129, 0.1)' }
                          }}
                        >
                          <WbSunny sx={{ fontSize: 18 }} />
                        </IconButton>
                        <Typography variant="caption" sx={{ color: layersVisible.weather ? '#10B981' : 'rgba(255,255,255,0.5)', minWidth: 80 }}>
                          Weather
                        </Typography>
                      </Box>
                      
                      {/* Weather Timeline Controls */}
                      {layersVisible.weather && weather.length > 0 && (
                        <Box sx={{ mt: 1, pt: 1, borderTop: '1px solid rgba(255,255,255,0.08)' }}>
                          <Stack spacing={1}>
                            {/* Current Date/Time Display */}
                            <Typography variant="caption" sx={{ fontFamily: 'monospace', color: 'text.secondary', fontSize: 9 }}>
                              {weather[weatherTimelineIndex]?.TIMESTAMP || 'Loading...'}
                            </Typography>
                            
                            {/* Temperature & Humidity Display */}
                            <Box sx={{ display: 'flex', gap: 1.5, alignItems: 'center' }}>
                              <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                <Thermostat sx={{ fontSize: 14, color: '#FBBF24' }} />
                                <Typography variant="caption" sx={{ color: '#FBBF24', fontSize: 10 }}>
                                  {weather[weatherTimelineIndex]?.TEMP_F?.toFixed(1) || '--'}¬∞F
                                </Typography>
                              </Box>
                              <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                <Opacity sx={{ fontSize: 14, color: '#3B82F6' }} />
                                <Typography variant="caption" sx={{ color: '#3B82F6', fontSize: 10 }}>
                                  {weather[weatherTimelineIndex]?.HUMIDITY_PCT?.toFixed(0) || '--'}%
                                </Typography>
                              </Box>
                            </Box>

                            {/* Timeline Scrubber */}
                            <Box>
                              <input
                                type="range"
                                min="0"
                                max={weather.length - 1}
                                value={weatherTimelineIndex}
                                onChange={(e) => {
                                  setWeatherTimelineIndex(parseInt(e.target.value));
                                  setIsWeatherPlaying(false);
                                }}
                                style={{
                                  width: '100%',
                                  height: '4px',
                                  accentColor: '#10B981',
                                  cursor: 'pointer'
                                }}
                              />
                              <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.25 }}>
                                <Typography variant="caption" sx={{ color: 'text.disabled', fontSize: 8 }}>
                                  Jul 1
                                </Typography>
                                <Typography variant="caption" sx={{ color: 'text.disabled', fontSize: 8 }}>
                                  {weatherTimelineIndex + 1}/{weather.length}
                                </Typography>
                                <Typography variant="caption" sx={{ color: 'text.disabled', fontSize: 8 }}>
                                  Aug 31
                                </Typography>
                              </Box>
                            </Box>

                            {/* Playback Controls */}
                            <Box sx={{ display: 'flex', gap: 0.25, justifyContent: 'center', alignItems: 'center' }}>
                              <IconButton 
                                size="small" 
                                onClick={() => setWeatherTimelineIndex(Math.max(0, weatherTimelineIndex - 24))}
                                sx={{ color: '#10B981', p: 0.5 }}
                              >
                                <SkipPrevious sx={{ fontSize: 16 }} />
                              </IconButton>
                              
                              <IconButton 
                                size="small" 
                                onClick={() => setWeatherTimelineIndex(Math.max(0, weatherTimelineIndex - 1))}
                                sx={{ color: '#10B981', p: 0.5 }}
                              >
                                <FastRewind sx={{ fontSize: 16 }} />
                              </IconButton>
                              
                              <IconButton 
                                size="small"
                                onClick={() => setIsWeatherPlaying(!isWeatherPlaying)}
                                sx={{ color: '#10B981', bgcolor: 'rgba(16, 185, 129, 0.1)', p: 0.5 }}
                              >
                                {isWeatherPlaying ? <Pause sx={{ fontSize: 16 }} /> : <PlayArrow sx={{ fontSize: 16 }} />}
                              </IconButton>
                              
                              <IconButton 
                                size="small" 
                                onClick={() => setWeatherTimelineIndex(Math.min(weather.length - 1, weatherTimelineIndex + 1))}
                                sx={{ color: '#10B981', p: 0.5 }}
                              >
                                <FastForward sx={{ fontSize: 16 }} />
                              </IconButton>
                              
                              <IconButton 
                                size="small" 
                                onClick={() => setWeatherTimelineIndex(Math.min(weather.length - 1, weatherTimelineIndex + 24))}
                                sx={{ color: '#10B981', p: 0.5 }}
                              >
                                <SkipNext sx={{ fontSize: 16 }} />
                              </IconButton>
                            </Box>

                            {/* Speed Control */}
                            <Box>
                              <Typography variant="caption" sx={{ display: 'block', mb: 0.25, color: 'text.secondary', fontSize: 9 }}>
                                Speed: {weatherSpeed}x hr/sec
                              </Typography>
                              <input
                                type="range"
                                min="1"
                                max="24"
                                value={weatherSpeed}
                                onChange={(e) => setWeatherSpeed(parseInt(e.target.value))}
                                style={{
                                  width: '100%',
                                  height: '4px',
                                  accentColor: '#10B981',
                                  cursor: 'pointer'
                                }}
                              />
                            </Box>
                          </Stack>
                        </Box>
                      )}
                        </Stack>
                      </Collapse>
                    </Stack>
                  </Paper>
                </Box>
                <DeckGL
                  initialViewState={viewState}
                  controller={{
                    dragPan: true,
                    dragRotate: true,
                    scrollZoom: true,
                    touchZoom: true,
                    touchRotate: true,
                    keyboard: true,
                    doubleClickZoom: false,
                    inertia: 600
                  }}
                  onViewStateChange={({viewState}: {viewState: any}) => {
                    // Normalize longitude to prevent wrapping issues
                    let normalizedLongitude = viewState.longitude;
                    if (normalizedLongitude !== undefined) {
                      while (normalizedLongitude > 180) normalizedLongitude -= 360;
                      while (normalizedLongitude < -180) normalizedLongitude += 360;
                    }
                    
                    const normalizedViewState = {
                      ...viewState,
                      longitude: normalizedLongitude
                    };
                    
                    // Throttle viewport updates to avoid performance violations
                    // Update immediately for responsive feel, but throttle heavy operations
                    pendingViewState.current = normalizedViewState;
                    
                    if (!viewportUpdateTimer.current) {
                      // Update immediately on first change
                      setViewState(normalizedViewState);
                      
                      // Throttle subsequent updates during continuous interaction
                      viewportUpdateTimer.current = setTimeout(() => {
                        if (pendingViewState.current) {
                          setViewState(pendingViewState.current);
                        }
                        viewportUpdateTimer.current = null;
                      }, 16); // ~60fps throttle
                    }
                  }}
                  onClick={(info) => {
                    const now = Date.now();
                    const timeSinceLastClick = now - lastClickTime;
                    const clickCoords: [number, number] = info.coordinate ? [info.coordinate[0], info.coordinate[1]] : [0, 0];
                    
                    // Check if this is a double-click (within 300ms and close proximity)
                    const isDoubleClick = timeSinceLastClick < 300 && 
                      lastClickCoords && 
                      Math.abs(lastClickCoords[0] - clickCoords[0]) < 0.01 &&
                      Math.abs(lastClickCoords[1] - clickCoords[1]) < 0.01;
                    
                    if (isDoubleClick) {
                      // Handle double-click zoom
                      handleDoubleClick(info);
                      // Reset click tracking
                      setLastClickTime(0);
                      setLastClickCoords(null);
                    } else {
                      // Single click - handle selection
                      if (!info.object) {
                        // Click on empty space (no asset clicked) clears selection
                        setSelectedAsset(null);
                        setSelectedAssetPosition(null);
                      }
                      // Update click tracking
                      setLastClickTime(now);
                      setLastClickCoords(clickCoords);
                    }
                  }}
                  onHover={(info) => {
                    // Optional: Could add hover effects here
                  }}
                  layers={layers}
                  glOptions={{
                    preserveDrawingBuffer: false,
                    antialias: true,
                    depth: true
                  }}
                  useDevicePixels={typeof window !== 'undefined' && window.devicePixelRatio > 1 ? 2 : 1}
                  getTooltip={() => null}
                >
                  <MapGL
                    {...viewState}
                    mapLib={maplibregl}
                    mapStyle={BASEMAP_URL}
                    reuseMaps
                    renderWorldCopies={false}
                    attributionControl={false}
                    interactive={false}
                  />
                </DeckGL>

                {/* Pinned Asset Cards */}
                {pinnedAssets.map((pinned) => {
                  const handleMouseDown = (e: React.MouseEvent) => {
                    if ((e.target as HTMLElement).closest('.drag-handle')) {
                      e.preventDefault();
                      setDraggedCardId(pinned.id);
                      setDragOffset({
                        x: e.clientX - pinned.position.x,
                        y: e.clientY - pinned.position.y
                      });
                    }
                  };

                  return (
                    <Fade key={pinned.id} in={true}>
                      <Paper 
                        onMouseDown={handleMouseDown}
                        sx={{ 
                          position: 'absolute', 
                          left: Math.min(pinned.position.x, window.innerWidth - 420),
                          top: pinned.position.y,
                          p: 3, 
                          width: 360,
                          maxHeight: 'calc(100vh - 40px)',
                          overflowY: 'auto',
                          overflowX: 'hidden',
                          bgcolor: alpha('#1E293B', 0.80),
                          backdropFilter: 'blur(12px)',
                          zIndex: draggedCardId === pinned.id ? 1002 : 1001,
                          borderLeft: `4px solid ${
                            pinned.asset.type === 'aggregate' ? (
                              pinned.asset.worstStatus === 'critical' ? '#EF4444' :
                              pinned.asset.worstStatus === 'warning' ? '#FBBF24' :
                              '#22C55E'
                            ) :
                            pinned.asset.type === 'substation' ? '#00C8FF' :
                            pinned.asset.type === 'transformer' ? '#A855F7' :
                            pinned.asset.type === 'pole' ? '#8880ff' : '#9333EA'
                          }`,
                          boxShadow: '0 8px 32px rgba(0,0,0,0.4)',
                          cursor: draggedCardId === pinned.id ? 'grabbing' : 'default',
                          userSelect: 'text',
                          wordWrap: 'break-word',
                          '&::-webkit-scrollbar': {
                            width: '8px',
                          },
                          '&::-webkit-scrollbar-track': {
                            bgcolor: alpha('#000', 0.2),
                          },
                          '&::-webkit-scrollbar-thumb': {
                            bgcolor: alpha('#fff', 0.3),
                            borderRadius: '4px',
                            '&:hover': {
                              bgcolor: alpha('#fff', 0.4),
                            },
                          },
                        }}
                      >
                        <Box className="drag-handle" sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2, cursor: 'grab', '&:active': { cursor: 'grabbing' } }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
                            {pinned.asset.type === 'aggregate' && <Assessment sx={{ 
                              color: pinned.asset.worstStatus === 'critical' ? '#EF4444' :
                                     pinned.asset.worstStatus === 'warning' ? '#FBBF24' : '#22C55E',
                              fontSize: 28 
                            }} />}
                            {pinned.asset.type === 'substation' && <ElectricBolt sx={{ color: '#00C8FF', fontSize: 28 }} />}
                            {pinned.asset.type === 'transformer' && <Assessment sx={{ color: '#EC4899', fontSize: 28 }} />}
                            {pinned.asset.type === 'pole' && <Engineering sx={{ color: '#8880ff', fontSize: 28 }} />}
                            {pinned.asset.type === 'meter' && <Speed sx={{ color: '#9333EA', fontSize: 28 }} />}
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 700, lineHeight: 1.2 }}>{pinned.asset.name}</Typography>
                              <Typography variant="caption" color="text.secondary" sx={{ fontFamily: 'monospace', letterSpacing: 0.5 }}>
                                {pinned.asset.id}
                              </Typography>
                            </Box>
                          </Box>
                          <Box sx={{ display: 'flex', gap: 0.5 }}>
                            <Tooltip title={pinned.collapsed ? "Expand card" : "Collapse card"}>
                              <IconButton 
                                size="small" 
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setPinnedAssets(prev => prev.map(p => 
                                    p.id === pinned.id ? { ...p, collapsed: !p.collapsed } : p
                                  ));
                                }}
                              >
                                {pinned.collapsed ? <ExpandMore sx={{ fontSize: 18 }} /> : <ExpandLess sx={{ fontSize: 18 }} />}
                              </IconButton>
                            </Tooltip>
                            <Tooltip title="Pinned - Click to unpin">
                              <IconButton 
                                size="small" 
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setPinnedAssets(prev => prev.filter(p => p.id !== pinned.id));
                                }}
                                sx={{ color: '#FBBF24' }}
                              >
                                <PushPin sx={{ fontSize: 18 }} />
                              </IconButton>
                            </Tooltip>
                            <IconButton 
                              size="small" 
                              onClick={(e) => {
                                e.stopPropagation();
                                setPinnedAssets(prev => prev.filter(p => p.id !== pinned.id));
                              }}
                            >
                              <Close sx={{ fontSize: 18 }} />
                            </IconButton>
                          </Box>
                        </Box>

                        <Chip 
                          label={pinned.asset.type.toUpperCase()} 
                          size="small" 
                          sx={{ mb: 2, fontWeight: 700, letterSpacing: 0.5 }} 
                        />

                        <Collapse in={!pinned.collapsed}>
                        <Stack spacing={2} divider={<Divider />}>
                          {pinned.asset.type === 'aggregate' && (
                            <>
                              <Stack direction="row" spacing={1}>
                                <Tooltip title="Center map on this cell">
                                  <Button 
                                    size="small" 
                                    variant="outlined" 
                                    startIcon={<MyLocation />}
                                    onClick={() => flyToAsset(pinned.asset.longitude, pinned.asset.latitude, 12)}
                                    sx={{ flex: 1, fontSize: 11 }}
                                  >
                                    Center
                                  </Button>
                                </Tooltip>
                                <Tooltip title="Zoom to see individual assets">
                                  <Button 
                                    size="small" 
                                    variant="outlined" 
                                    startIcon={<ZoomIn />}
                                    onClick={() => flyToAsset(pinned.asset.longitude, pinned.asset.latitude, 13)}
                                    sx={{ flex: 1, fontSize: 11 }}
                                  >
                                    Zoom In
                                  </Button>
                                </Tooltip>
                              </Stack>

                              {pinned.asset.worstStatus === 'critical' && (
                                <Paper sx={{ 
                                  p: 1.5, 
                                  bgcolor: alpha('#EF4444', 0.1), 
                                  border: '1px solid',
                                  borderColor: alpha('#EF4444', 0.3)
                                }}>
                                  <Stack direction="row" spacing={1} alignItems="center">
                                    <Warning sx={{ color: '#EF4444', fontSize: 20 }} />
                                    <Box>
                                      <Typography variant="caption" fontWeight={700} color="#EF4444">
                                        CRITICAL AREA
                                      </Typography>
                                      <Typography variant="caption" display="block" color="text.secondary">
                                        Requires immediate attention
                                      </Typography>
                                    </Box>
                                  </Stack>
                                </Paper>
                              )}

                              <Box>
                                <Stack direction="row" spacing={1} alignItems="center" sx={{ mb: 1 }}>
                                  <GridOn sx={{ fontSize: 16, color: 'text.secondary' }} />
                                  <Typography variant="caption" color="text.secondary" fontWeight={600}>
                                    INFRASTRUCTURE SUMMARY
                                  </Typography>
                                </Stack>
                                <Stack spacing={1}>
                                  {/* Substations - Expandable */}
                                  <Box>
                                    <Box 
                                      sx={{ 
                                        display: 'flex', 
                                        justifyContent: 'space-between', 
                                        alignItems: 'center',
                                        cursor: pinned.asset.substations?.length > 0 ? 'pointer' : 'default',
                                        '&:hover': pinned.asset.substations?.length > 0 ? { bgcolor: alpha('#fff', 0.03) } : {},
                                        p: 0.5,
                                        borderRadius: 1,
                                        transition: 'background-color 0.2s'
                                      }}
                                      onClick={() => {
                                        if (pinned.asset.substations?.length > 0) {
                                          setExpandedAssetCategories(prev => ({
                                            ...prev,
                                            [pinned.id]: {
                                              ...(prev[pinned.id] || {}),
                                              substations: !prev[pinned.id]?.substations,
                                              transformers: prev[pinned.id]?.transformers || false,
                                              poles: prev[pinned.id]?.poles || false,
                                              meters: prev[pinned.id]?.meters || false
                                            }
                                          }));
                                        }
                                      }}
                                    >
                                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        <Typography variant="body2" color="text.secondary">Substations</Typography>
                                        {pinned.asset.substations?.length > 0 && (
                                          <IconButton size="small" sx={{ p: 0 }}>
                                            {expandedAssetCategories[pinned.id]?.substations ? 
                                              <ExpandLess sx={{ fontSize: 16 }} /> : 
                                              <ExpandMore sx={{ fontSize: 16 }} />
                                            }
                                          </IconButton>
                                        )}
                                      </Box>
                                      <Chip label={pinned.asset.substationCount || 0} size="small" sx={{ bgcolor: alpha('#00C8FF', 0.15), color: '#00C8FF' }} />
                                    </Box>
                                    
                                    <Collapse in={expandedAssetCategories[pinned.id]?.substations}>
                                      <Stack spacing={0.5} sx={{ pl: 2, mt: 0.5, maxHeight: 200, overflowY: 'auto' }}>
                                        {pinned.asset.substations?.map((substation: Asset) => (
                                          <Box 
                                            key={substation.id} 
                                            onClick={() => {
                                              setSelectedAsset({
                                                ...substation,
                                                type: 'substation',
                                                name: substation.name || substation.id,
                                                latitude: substation.latitude || substation.coords?.[1],
                                                longitude: substation.longitude || substation.coords?.[0]
                                              });
                                              flyToAsset(
                                                substation.longitude || substation.coords?.[0],
                                                substation.latitude || substation.coords?.[1],
                                                15
                                              );
                                            }}
                                            sx={{ 
                                              p: 1, 
                                              bgcolor: alpha('#00C8FF', 0.05), 
                                              borderLeft: `2px solid ${alpha('#00C8FF', 0.3)}`,
                                              borderRadius: 1,
                                              cursor: 'pointer',
                                              transition: 'all 0.2s',
                                              '&:hover': {
                                                bgcolor: alpha('#00C8FF', 0.15),
                                                transform: 'translateX(4px)'
                                              }
                                            }}
                                          >
                                            <Typography variant="caption" fontWeight={600} color="#00C8FF" display="block">
                                              {substation.name || substation.id}
                                            </Typography>
                                            <Typography variant="caption" display="block" sx={{ fontFamily: 'monospace', fontSize: 9, color: 'text.secondary' }}>
                                              ID: {substation.id}
                                            </Typography>
                                            {substation.health_score !== undefined && (
                                              <Typography variant="caption" display="block" sx={{ fontSize: 9 }}>
                                                Health: {substation.health_score}%
                                              </Typography>
                                            )}
                                          </Box>
                                        ))}
                                      </Stack>
                                    </Collapse>
                                  </Box>

                                  {/* Transformers - Expandable */}
                                  <Box>
                                    <Box 
                                      sx={{ 
                                        display: 'flex', 
                                        justifyContent: 'space-between', 
                                        alignItems: 'center',
                                        cursor: pinned.asset.transformers?.length > 0 ? 'pointer' : 'default',
                                        '&:hover': pinned.asset.transformers?.length > 0 ? { bgcolor: alpha('#fff', 0.03) } : {},
                                        p: 0.5,
                                        borderRadius: 1,
                                        transition: 'background-color 0.2s'
                                      }}
                                      onClick={() => {
                                        if (pinned.asset.transformers?.length > 0) {
                                          setExpandedAssetCategories(prev => ({
                                            ...prev,
                                            [pinned.id]: {
                                              ...(prev[pinned.id] || {}),
                                              substations: prev[pinned.id]?.substations || false,
                                              transformers: !prev[pinned.id]?.transformers,
                                              poles: prev[pinned.id]?.poles || false,
                                              meters: prev[pinned.id]?.meters || false
                                            }
                                          }));
                                        }
                                      }}
                                    >
                                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        <Typography variant="body2" color="text.secondary">Transformers</Typography>
                                        {pinned.asset.transformers?.length > 0 && (
                                          <IconButton size="small" sx={{ p: 0 }}>
                                            {expandedAssetCategories[pinned.id]?.transformers ? 
                                              <ExpandLess sx={{ fontSize: 16 }} /> : 
                                              <ExpandMore sx={{ fontSize: 16 }} />
                                            }
                                          </IconButton>
                                        )}
                                      </Box>
                                      <Chip label={pinned.asset.transformerCount || 0} size="small" sx={{ bgcolor: alpha('#EC4899', 0.15), color: '#EC4899' }} />
                                    </Box>
                                    
                                    <Collapse in={expandedAssetCategories[pinned.id]?.transformers}>
                                      <Stack spacing={0.5} sx={{ pl: 2, mt: 0.5, maxHeight: 200, overflowY: 'auto' }}>
                                        {pinned.asset.transformers?.map((transformer: Asset) => (
                                          <Box 
                                            key={transformer.id}
                                            onClick={() => {
                                              setSelectedAsset({
                                                ...transformer,
                                                type: 'transformer',
                                                name: transformer.name || transformer.id,
                                                latitude: transformer.latitude || transformer.coords?.[1],
                                                longitude: transformer.longitude || transformer.coords?.[0]
                                              });
                                              flyToAsset(
                                                transformer.longitude || transformer.coords?.[0],
                                                transformer.latitude || transformer.coords?.[1],
                                                15
                                              );
                                            }}
                                            sx={{ 
                                              p: 1, 
                                              bgcolor: alpha('#EC4899', 0.05), 
                                              borderLeft: `2px solid ${alpha('#EC4899', 0.3)}`,
                                              borderRadius: 1,
                                              cursor: 'pointer',
                                              transition: 'all 0.2s',
                                              '&:hover': {
                                                bgcolor: alpha('#EC4899', 0.15),
                                                transform: 'translateX(4px)'
                                              }
                                            }}
                                          >
                                            <Typography variant="caption" fontWeight={600} color="#EC4899" display="block">
                                              {transformer.name || transformer.id}
                                            </Typography>
                                            <Typography variant="caption" display="block" sx={{ fontFamily: 'monospace', fontSize: 9, color: 'text.secondary' }}>
                                              ID: {transformer.id}
                                            </Typography>
                                            {transformer.health_score !== undefined && (
                                              <Typography variant="caption" display="block" sx={{ fontSize: 9 }}>
                                                Health: {transformer.health_score}%
                                              </Typography>
                                            )}
                                            {transformer.load_percent !== undefined && (
                                              <Typography variant="caption" display="block" sx={{ fontSize: 9 }}>
                                                Load: {transformer.load_percent}%
                                              </Typography>
                                            )}
                                          </Box>
                                        ))}
                                      </Stack>
                                    </Collapse>
                                  </Box>

                                  {/* Poles - Expandable */}
                                  <Box>
                                    <Box 
                                      sx={{ 
                                        display: 'flex', 
                                        justifyContent: 'space-between', 
                                        alignItems: 'center',
                                        cursor: pinned.asset.poles?.length > 0 ? 'pointer' : 'default',
                                        '&:hover': pinned.asset.poles?.length > 0 ? { bgcolor: alpha('#fff', 0.03) } : {},
                                        p: 0.5,
                                        borderRadius: 1,
                                        transition: 'background-color 0.2s'
                                      }}
                                      onClick={() => {
                                        if (pinned.asset.poles?.length > 0) {
                                          setExpandedAssetCategories(prev => ({
                                            ...prev,
                                            [pinned.id]: {
                                              ...(prev[pinned.id] || {}),
                                              substations: prev[pinned.id]?.substations || false,
                                              transformers: prev[pinned.id]?.transformers || false,
                                              poles: !prev[pinned.id]?.poles,
                                              meters: prev[pinned.id]?.meters || false
                                            }
                                          }));
                                        }
                                      }}
                                    >
                                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        <Typography variant="body2" color="text.secondary">Poles</Typography>
                                        {pinned.asset.poles?.length > 0 && (
                                          <IconButton size="small" sx={{ p: 0 }}>
                                            {expandedAssetCategories[pinned.id]?.poles ? 
                                              <ExpandLess sx={{ fontSize: 16 }} /> : 
                                              <ExpandMore sx={{ fontSize: 16 }} />
                                            }
                                          </IconButton>
                                        )}
                                      </Box>
                                      <Chip label={pinned.asset.poleCount || 0} size="small" sx={{ bgcolor: alpha('#8880ff', 0.15), color: '#8880ff' }} />
                                    </Box>
                                    
                                    <Collapse in={expandedAssetCategories[pinned.id]?.poles}>
                                      <Stack spacing={0.5} sx={{ pl: 2, mt: 0.5, maxHeight: 200, overflowY: 'auto' }}>
                                        {pinned.asset.poles?.map((pole: Asset) => (
                                          <Box 
                                            key={pole.id}
                                            onClick={() => {
                                              setSelectedAsset({
                                                ...pole,
                                                type: 'pole',
                                                name: pole.name || pole.id,
                                                latitude: pole.latitude || pole.coords?.[1],
                                                longitude: pole.longitude || pole.coords?.[0]
                                              });
                                              flyToAsset(
                                                pole.longitude || pole.coords?.[0],
                                                pole.latitude || pole.coords?.[1],
                                                15
                                              );
                                            }}
                                            sx={{ 
                                              p: 1, 
                                              bgcolor: alpha('#8880ff', 0.05), 
                                              borderLeft: `2px solid ${alpha('#8880ff', 0.3)}`,
                                              borderRadius: 1,
                                              cursor: 'pointer',
                                              transition: 'all 0.2s',
                                              '&:hover': {
                                                bgcolor: alpha('#8880ff', 0.15),
                                                transform: 'translateX(4px)'
                                              }
                                            }}
                                          >
                                            <Typography variant="caption" fontWeight={600} color="#8880ff" display="block">
                                              {pole.name || pole.id}
                                            </Typography>
                                            <Typography variant="caption" display="block" sx={{ fontFamily: 'monospace', fontSize: 9, color: 'text.secondary' }}>
                                              ID: {pole.id}
                                            </Typography>
                                            {pole.health_score !== undefined && (
                                              <Typography variant="caption" display="block" sx={{ fontSize: 9 }}>
                                                Health: {pole.health_score}%
                                              </Typography>
                                            )}
                                          </Box>
                                        ))}
                                      </Stack>
                                    </Collapse>
                                  </Box>

                                  {/* Meters - Expandable */}
                                  <Box>
                                    <Box 
                                      sx={{ 
                                        display: 'flex', 
                                        justifyContent: 'space-between', 
                                        alignItems: 'center', 
                                        p: 0.5,
                                        cursor: pinned.asset.meters?.length > 0 ? 'pointer' : 'default',
                                        '&:hover': pinned.asset.meters?.length > 0 ? {
                                          bgcolor: alpha('#9333EA', 0.05)
                                        } : {},
                                        borderRadius: 1,
                                        transition: 'background-color 0.2s'
                                      }}
                                      onClick={() => {
                                        if (pinned.asset.meters?.length > 0) {
                                          setExpandedAssetCategories(prev => ({
                                            ...prev,
                                            [pinned.id]: {
                                              ...(prev[pinned.id] || {}),
                                              substations: prev[pinned.id]?.substations || false,
                                              transformers: prev[pinned.id]?.transformers || false,
                                              poles: prev[pinned.id]?.poles || false,
                                              meters: !prev[pinned.id]?.meters
                                            }
                                          }));
                                        }
                                      }}
                                    >
                                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        <Typography variant="body2" color="text.secondary">Meters</Typography>
                                        {pinned.asset.meters?.length > 0 && (
                                          <IconButton size="small" sx={{ p: 0 }}>
                                            {expandedAssetCategories[pinned.id]?.meters ? 
                                              <ExpandLess sx={{ fontSize: 16 }} /> : 
                                              <ExpandMore sx={{ fontSize: 16 }} />
                                            }
                                          </IconButton>
                                        )}
                                      </Box>
                                      <Chip label={pinned.asset.meterCount || 0} size="small" sx={{ bgcolor: alpha('#9333EA', 0.15), color: '#9333EA' }} />
                                    </Box>
                                    
                                    <Collapse in={expandedAssetCategories[pinned.id]?.meters}>
                                      <Stack spacing={0.5} sx={{ pl: 2, mt: 0.5, maxHeight: 200, overflowY: 'auto' }}>
                                        {pinned.asset.meters?.map((meter: Asset) => (
                                          <Box 
                                            key={meter.id}
                                            onClick={() => {
                                              setSelectedAsset({
                                                ...meter,
                                                type: 'meter',
                                                name: meter.name || meter.id,
                                                latitude: meter.latitude || meter.coords?.[1],
                                                longitude: meter.longitude || meter.coords?.[0]
                                              });
                                              flyToAsset(
                                                meter.longitude || meter.coords?.[0],
                                                meter.latitude || meter.coords?.[1],
                                                15
                                              );
                                            }}
                                            sx={{ 
                                              p: 1, 
                                              bgcolor: alpha('#9333EA', 0.05), 
                                              borderLeft: `2px solid ${alpha('#9333EA', 0.3)}`,
                                              borderRadius: 1,
                                              cursor: 'pointer',
                                              transition: 'all 0.2s',
                                              '&:hover': {
                                                bgcolor: alpha('#9333EA', 0.15),
                                                transform: 'translateX(4px)'
                                              }
                                            }}
                                          >
                                            <Typography variant="caption" fontWeight={600} color="#9333EA" display="block">
                                              {meter.name || meter.id}
                                            </Typography>
                                            <Typography variant="caption" display="block" sx={{ fontFamily: 'monospace', fontSize: 9, color: 'text.secondary' }}>
                                              ID: {meter.id}
                                            </Typography>
                                            {meter.usage_kwh !== undefined && (
                                              <Typography variant="caption" display="block" sx={{ fontSize: 9 }}>
                                                Usage: {meter.usage_kwh} kWh
                                              </Typography>
                                            )}
                                          </Box>
                                        ))}
                                      </Stack>
                                    </Collapse>
                                  </Box>
                                </Stack>
                              </Box>

                              <Box>
                                <Box
                                  sx={{ cursor: 'pointer', mb: 1 }}
                                  onClick={() => setExpandedSections(prev => ({ ...prev, healthStatus: !prev.healthStatus }))}
                                >
                                  <Stack direction="row" spacing={1} alignItems="center" justifyContent="space-between">
                                    <Stack direction="row" spacing={1} alignItems="center">
                                      <FavoriteOutlined sx={{ fontSize: 16, color: 'text.secondary' }} />
                                      <Typography variant="caption" color="text.secondary" fontWeight={600}>
                                        HEALTH STATUS
                                      </Typography>
                                    </Stack>
                                    <IconButton size="small">
                                      {expandedSections.healthStatus ? <ExpandLess sx={{ fontSize: 16 }} /> : <ExpandMore sx={{ fontSize: 16 }} />}
                                    </IconButton>
                                  </Stack>
                                </Box>
                                
                                <Collapse in={expandedSections.healthStatus}>
                                  <Stack spacing={1}>
                                    {/* Critical Assets - Expandable */}
                                    <Box>
                                      <Box 
                                        sx={{ 
                                          display: 'flex', 
                                          justifyContent: 'space-between', 
                                          alignItems: 'center',
                                          cursor: pinned.asset.assetsByHealth?.critical?.length > 0 ? 'pointer' : 'default',
                                          p: 0.5,
                                          borderRadius: 1,
                                          '&:hover': pinned.asset.assetsByHealth?.critical?.length > 0 ? {
                                            bgcolor: alpha('#EF4444', 0.05)
                                          } : {}
                                        }}
                                        onClick={() => {
                                          if (pinned.asset.assetsByHealth?.critical?.length > 0) {
                                            setExpandedAssetCategories(prev => ({
                                              ...prev,
                                              [pinned.id]: {
                                                ...(prev[pinned.id] || {}),
                                                criticalAssets: !prev[pinned.id]?.criticalAssets
                                              }
                                            }));
                                          }
                                        }}
                                      >
                                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                          <Typography variant="body2" color="text.secondary">Critical Assets</Typography>
                                          {pinned.asset.assetsByHealth?.critical?.length > 0 && (
                                            <IconButton size="small" sx={{ p: 0 }}>
                                              {expandedAssetCategories[pinned.id]?.criticalAssets ? 
                                                <ExpandLess sx={{ fontSize: 16 }} /> : 
                                                <ExpandMore sx={{ fontSize: 16 }} />
                                              }
                                            </IconButton>
                                          )}
                                        </Box>
                                        <Chip label={pinned.asset.criticalCount || 0} size="small" sx={{ bgcolor: alpha('#EF4444', 0.15), color: '#EF4444' }} />
                                      </Box>
                                      
                                      <Collapse in={expandedAssetCategories[pinned.id]?.criticalAssets}>
                                        <Stack spacing={0.5} sx={{ pl: 2, mt: 0.5, maxHeight: 150, overflowY: 'auto' }}>
                                          {pinned.asset.assetsByHealth?.critical?.map((asset: Asset) => (
                                            <Box 
                                              key={asset.id}
                                              onClick={() => {
                                                setSelectedAsset(asset);
                                                flyToAsset(asset.longitude, asset.latitude, 15);
                                              }}
                                              sx={{ 
                                                p: 1, 
                                                bgcolor: alpha('#EF4444', 0.05), 
                                                borderLeft: `2px solid ${alpha('#EF4444', 0.5)}`,
                                                borderRadius: 1,
                                                cursor: 'pointer',
                                                transition: 'all 0.2s',
                                                '&:hover': {
                                                  bgcolor: alpha('#EF4444', 0.15),
                                                  transform: 'translateX(4px)'
                                                }
                                              }}
                                            >
                                              <Typography variant="caption" fontWeight={600} color="#EF4444" display="block">
                                                {asset.name || asset.id} ({asset.type})
                                              </Typography>
                                              {asset.health_score !== undefined && (
                                                <Typography variant="caption" display="block" sx={{ fontSize: 9, color: 'text.secondary' }}>
                                                  Health: {asset.health_score}%
                                                </Typography>
                                              )}
                                            </Box>
                                          ))}
                                        </Stack>
                                      </Collapse>
                                    </Box>

                                    {/* Warning Assets - Expandable */}
                                    <Box>
                                      <Box 
                                        sx={{ 
                                          display: 'flex', 
                                          justifyContent: 'space-between', 
                                          alignItems: 'center',
                                          cursor: pinned.asset.assetsByHealth?.warning?.length > 0 ? 'pointer' : 'default',
                                          p: 0.5,
                                          borderRadius: 1,
                                          '&:hover': pinned.asset.assetsByHealth?.warning?.length > 0 ? {
                                            bgcolor: alpha('#FBBF24', 0.05)
                                          } : {}
                                        }}
                                        onClick={() => {
                                          if (pinned.asset.assetsByHealth?.warning?.length > 0) {
                                            setExpandedAssetCategories(prev => ({
                                              ...prev,
                                              [pinned.id]: {
                                                ...(prev[pinned.id] || {}),
                                                warningAssets: !prev[pinned.id]?.warningAssets
                                              }
                                            }));
                                          }
                                        }}
                                      >
                                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                          <Typography variant="body2" color="text.secondary">Warning Assets</Typography>
                                          {pinned.asset.assetsByHealth?.warning?.length > 0 && (
                                            <IconButton size="small" sx={{ p: 0 }}>
                                              {expandedAssetCategories[pinned.id]?.warningAssets ? 
                                                <ExpandLess sx={{ fontSize: 16 }} /> : 
                                                <ExpandMore sx={{ fontSize: 16 }} />
                                              }
                                            </IconButton>
                                          )}
                                        </Box>
                                        <Chip label={pinned.asset.warningCount || 0} size="small" sx={{ bgcolor: alpha('#FBBF24', 0.15), color: '#FBBF24' }} />
                                      </Box>
                                      
                                      <Collapse in={expandedAssetCategories[pinned.id]?.warningAssets}>
                                        <Stack spacing={0.5} sx={{ pl: 2, mt: 0.5, maxHeight: 150, overflowY: 'auto' }}>
                                          {pinned.asset.assetsByHealth?.warning?.map((asset: Asset) => (
                                            <Box 
                                              key={asset.id}
                                              onClick={() => {
                                                setSelectedAsset(asset);
                                                flyToAsset(asset.longitude, asset.latitude, 15);
                                              }}
                                              sx={{ 
                                                p: 1, 
                                                bgcolor: alpha('#FBBF24', 0.05), 
                                                borderLeft: `2px solid ${alpha('#FBBF24', 0.5)}`,
                                                borderRadius: 1,
                                                cursor: 'pointer',
                                                transition: 'all 0.2s',
                                                '&:hover': {
                                                  bgcolor: alpha('#FBBF24', 0.15),
                                                  transform: 'translateX(4px)'
                                                }
                                              }}
                                            >
                                              <Typography variant="caption" fontWeight={600} color="#FBBF24" display="block">
                                                {asset.name || asset.id} ({asset.type})
                                              </Typography>
                                              {asset.health_score !== undefined && (
                                                <Typography variant="caption" display="block" sx={{ fontSize: 9, color: 'text.secondary' }}>
                                                  Health: {asset.health_score}%
                                                </Typography>
                                              )}
                                            </Box>
                                          ))}
                                        </Stack>
                                      </Collapse>
                                    </Box>

                                    {/* Healthy Assets - Expandable */}
                                    <Box>
                                      <Box 
                                        sx={{ 
                                          display: 'flex', 
                                          justifyContent: 'space-between', 
                                          alignItems: 'center',
                                          cursor: pinned.asset.assetsByHealth?.healthy?.length > 0 ? 'pointer' : 'default',
                                          p: 0.5,
                                          borderRadius: 1,
                                          '&:hover': pinned.asset.assetsByHealth?.healthy?.length > 0 ? {
                                            bgcolor: alpha('#22C55E', 0.05)
                                          } : {}
                                        }}
                                        onClick={() => {
                                          if (pinned.asset.assetsByHealth?.healthy?.length > 0) {
                                            setExpandedAssetCategories(prev => ({
                                              ...prev,
                                              [pinned.id]: {
                                                ...(prev[pinned.id] || {}),
                                                healthyAssets: !prev[pinned.id]?.healthyAssets
                                              }
                                            }));
                                          }
                                        }}
                                      >
                                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                          <Typography variant="body2" color="text.secondary">Healthy Assets</Typography>
                                          {pinned.asset.assetsByHealth?.healthy?.length > 0 && (
                                            <IconButton size="small" sx={{ p: 0 }}>
                                              {expandedAssetCategories[pinned.id]?.healthyAssets ? 
                                                <ExpandLess sx={{ fontSize: 16 }} /> : 
                                                <ExpandMore sx={{ fontSize: 16 }} />
                                              }
                                            </IconButton>
                                          )}
                                        </Box>
                                        <Chip label={pinned.asset.healthyCount || 0} size="small" sx={{ bgcolor: alpha('#22C55E', 0.15), color: '#22C55E' }} />
                                      </Box>
                                      
                                      <Collapse in={expandedAssetCategories[pinned.id]?.healthyAssets}>
                                        <Stack spacing={0.5} sx={{ pl: 2, mt: 0.5, maxHeight: 150, overflowY: 'auto' }}>
                                          {pinned.asset.assetsByHealth?.healthy?.map((asset: Asset) => (
                                            <Box 
                                              key={asset.id}
                                              onClick={() => {
                                                setSelectedAsset(asset);
                                                flyToAsset(asset.longitude, asset.latitude, 15);
                                              }}
                                              sx={{ 
                                                p: 1, 
                                                bgcolor: alpha('#22C55E', 0.05), 
                                                borderLeft: `2px solid ${alpha('#22C55E', 0.5)}`,
                                                borderRadius: 1,
                                                cursor: 'pointer',
                                                transition: 'all 0.2s',
                                                '&:hover': {
                                                  bgcolor: alpha('#22C55E', 0.15),
                                                  transform: 'translateX(4px)'
                                                }
                                              }}
                                            >
                                              <Typography variant="caption" fontWeight={600} color="#22C55E" display="block">
                                                {asset.name || asset.id} ({asset.type})
                                              </Typography>
                                              {asset.health_score !== undefined && (
                                                <Typography variant="caption" display="block" sx={{ fontSize: 9, color: 'text.secondary' }}>
                                                  Health: {asset.health_score}%
                                                </Typography>
                                              )}
                                            </Box>
                                          ))}
                                        </Stack>
                                      </Collapse>
                                    </Box>
                                  </Stack>
                                </Collapse>
                              </Box>
                            </>
                          )}

                          {pinned.asset.type !== 'aggregate' && (
                            <>
                              <Box>
                                <Typography variant="caption" color="text.secondary">Status</Typography>
                                <Chip 
                                  label={pinned.asset.status?.toUpperCase() || 'OPERATIONAL'} 
                                  size="small" 
                                  sx={{ 
                                    mt: 0.5,
                                    bgcolor: alpha('#22C55E', 0.15), 
                                    color: '#22C55E',
                                    fontWeight: 700 
                                  }} 
                                />
                              </Box>
                              {pinned.asset.capacity && (
                                <Box>
                                  <Typography variant="caption" color="text.secondary">Capacity</Typography>
                                  <Typography variant="body2">{pinned.asset.capacity}</Typography>
                                </Box>
                              )}
                              {pinned.asset.voltage && (
                                <Box>
                                  <Typography variant="caption" color="text.secondary">Voltage</Typography>
                                  <Typography variant="body2">{pinned.asset.voltage}</Typography>
                                </Box>
                              )}
                              {pinned.asset.type === 'pole' && pinned.asset.pole_height_ft && (
                                <Box>
                                  <Typography variant="caption" color="text.secondary">Pole Height</Typography>
                                  <Typography variant="body2" sx={{ color: '#8880ff', fontWeight: 600 }}>
                                    {pinned.asset.pole_height_ft} ft
                                  </Typography>
                                </Box>
                              )}
                            </>
                          )}

                          <Box>
                            <Typography variant="caption" color="text.secondary">Coordinates</Typography>
                            <Typography variant="body2" sx={{ fontFamily: 'monospace', fontSize: 11 }}>
                              {pinned.asset.latitude.toFixed(6)}, {pinned.asset.longitude.toFixed(6)}
                            </Typography>
                          </Box>
                        </Stack>
                        </Collapse>
                      </Paper>
                    </Fade>
                  );
                })}

                {/* Selected Asset Panel (Active/Unpinned) */}
                {selectedAsset && clickPosition && !pinnedAssets.some(p => p.asset.id === selectedAsset.id) && (() => {
                  // Engineering: Intelligent positioning to ensure full info card visibility
                  const CARD_WIDTH = 380;
                  const CARD_HEIGHT = 700; // Increased estimate for scrollability
                  const MARGIN = 20;
                  const EDGE_THRESHOLD = 60; // Increased threshold for better edge detection
                  
                  // Detect proximity to screen edges with viewport awareness
                  const viewportWidth = window.innerWidth;
                  const viewportHeight = window.innerHeight;
                  const nearRight = clickPosition.x + CARD_WIDTH + EDGE_THRESHOLD > viewportWidth;
                  const nearBottom = clickPosition.y + CARD_HEIGHT + EDGE_THRESHOLD > viewportHeight;
                  const nearLeft = clickPosition.x < EDGE_THRESHOLD;
                  const nearTop = clickPosition.y < EDGE_THRESHOLD;
                  
                  // Smart positioning with corner case handling
                  let cardLeft: number;
                  let cardTop: number;
                  
                  // Horizontal positioning
                  if (nearRight && !nearLeft) {
                    cardLeft = Math.max(10, clickPosition.x - CARD_WIDTH - MARGIN);
                  } else if (nearLeft) {
                    cardLeft = Math.min(clickPosition.x + MARGIN, viewportWidth - CARD_WIDTH - 10);
                  } else {
                    cardLeft = Math.min(clickPosition.x + MARGIN, viewportWidth - CARD_WIDTH - 10);
                  }
                  
                  // Vertical positioning
                  if (nearBottom && !nearTop) {
                    cardTop = Math.max(10, clickPosition.y - CARD_HEIGHT - MARGIN);
                  } else if (nearTop) {
                    cardTop = Math.min(clickPosition.y + MARGIN, viewportHeight - CARD_HEIGHT - 10);
                  } else {
                    cardTop = Math.min(clickPosition.y + MARGIN, viewportHeight - CARD_HEIGHT - 10);
                  }
                  
                  // Ensure card stays within bounds
                  cardLeft = Math.max(10, Math.min(cardLeft, viewportWidth - CARD_WIDTH - 10));
                  cardTop = Math.max(10, Math.min(cardTop, viewportHeight - 200)); // Ensure at least 200px visible
                  
                  // Use stored position if being dragged, otherwise use calculated position
                  if (selectedAssetPosition) {
                    cardLeft = selectedAssetPosition.x;
                    cardTop = selectedAssetPosition.y;
                  }
                  
                  const isPinned = pinnedAssets.some(p => p.asset.id === selectedAsset.id);

                  const handlePinToggle = () => {
                    if (isPinned) {
                      setPinnedAssets(prev => prev.filter(p => p.asset.id !== selectedAsset.id));
                    } else {
                      // Pin the asset and clear selected asset to prevent dual cards
                      setPinnedAssets(prev => [...prev, {
                        id: selectedAsset.id,
                        asset: selectedAsset,
                        position: { x: cardLeft, y: cardTop },
                        collapsed: false
                      }]);
                      // Clear selected asset and click position to hide the active card
                      setSelectedAsset(null);
                      setClickPosition(null);
                    }
                  };

                  const handleMouseDown = (e: React.MouseEvent) => {
                    if ((e.target as HTMLElement).closest('.drag-handle')) {
                      e.preventDefault();
                      setDraggedCardId(selectedAsset.id);
                      setDragOffset({
                        x: e.clientX - cardLeft,
                        y: e.clientY - cardTop
                      });
                    }
                  };
                  
                  return (
                    <Fade in={true}>
                      <Paper 
                        onMouseDown={handleMouseDown}
                        sx={{ 
                        position: 'absolute', 
                        left: cardLeft,
                        top: cardTop,
                        p: 3, 
                        minWidth: 320,
                        maxWidth: 380,
                        maxHeight: 'calc(100vh - 40px)',
                        overflowY: 'auto',
                        overflowX: 'hidden',
                        bgcolor: alpha('#1E293B', 0.80),
                        backdropFilter: 'blur(12px)',
                        zIndex: 1000,
                        borderLeft: `4px solid ${
                          selectedAsset.type === 'aggregate' ? (
                            // Engineering: Priority-based border for aggregate cells
                            selectedAsset.worstStatus === 'critical' ? '#EF4444' :  // Red for critical
                            selectedAsset.worstStatus === 'warning' ? '#FBBF24' :   // Amber for warning
                            '#22C55E'  // Green for healthy
                          ) :
                          selectedAsset.type === 'substation' ? '#00C8FF' :
                          selectedAsset.type === 'transformer' ? '#EC4899' :
                          selectedAsset.type === 'pole' ? '#8880ff' : '#9333EA'
                        }`,
                        boxShadow: '0 8px 32px rgba(0,0,0,0.4)',
                        cursor: draggedCardId === selectedAsset.id ? 'grabbing' : 'default',
                        userSelect: 'text',
                        '&::-webkit-scrollbar': {
                          width: '8px',
                        },
                        '&::-webkit-scrollbar-track': {
                          bgcolor: alpha('#000', 0.2),
                        },
                        '&::-webkit-scrollbar-thumb': {
                          bgcolor: alpha('#fff', 0.3),
                          borderRadius: '4px',
                          '&:hover': {
                            bgcolor: alpha('#fff', 0.4),
                          },
                        },
                      }}>
                      <Box className="drag-handle" sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2, cursor: 'grab', '&:active': { cursor: 'grabbing' } }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
                          {selectedAsset.type === 'aggregate' && <Assessment sx={{ 
                            color: selectedAsset.worstStatus === 'critical' ? '#EF4444' :
                                   selectedAsset.worstStatus === 'warning' ? '#FBBF24' : '#22C55E',
                            fontSize: 28 
                          }} />}
                          {selectedAsset.type === 'substation' && <ElectricBolt sx={{ color: '#00C8FF', fontSize: 28 }} />}
                          {selectedAsset.type === 'transformer' && <Assessment sx={{ color: '#EC4899', fontSize: 28 }} />}
                          {selectedAsset.type === 'pole' && <Engineering sx={{ color: '#8880ff', fontSize: 28 }} />}
                          {selectedAsset.type === 'meter' && <Speed sx={{ color: '#9333EA', fontSize: 28 }} />}
                          <Box>
                            <Typography variant="h6" sx={{ fontWeight: 700, lineHeight: 1.2 }}>{selectedAsset.name}</Typography>
                            <Typography variant="caption" color="text.secondary" sx={{ 
                              fontFamily: 'monospace', 
                              letterSpacing: 0.5,
                              maxWidth: 280,
                              overflow: 'hidden',
                              textOverflow: 'ellipsis',
                              whiteSpace: 'nowrap'
                            }}>
                              {selectedAsset.id}
                            </Typography>
                          </Box>
                        </Box>
                        <Box sx={{ display: 'flex', gap: 0.5 }}>
                          <Tooltip title={isPinned ? "Unpin card" : "Pin card for comparison"}>
                            <IconButton 
                              size="small" 
                              onClick={handlePinToggle}
                              sx={{ color: isPinned ? '#FBBF24' : 'inherit' }}
                            >
                              <PushPin sx={{ fontSize: 18 }} />
                            </IconButton>
                          </Tooltip>
                          <IconButton size="small" onClick={() => {
                            setSelectedAsset(null);
                            setSelectedAssetPosition(null);
                          }}>
                            <Close sx={{ fontSize: 18 }} />
                          </IconButton>
                        </Box>
                      </Box>

                      <Chip 
                        label={selectedAsset.type.toUpperCase()} 
                        size="small" 
                        sx={{ mb: 2, fontWeight: 700, letterSpacing: 0.5 }} 
                      />

                      <Stack spacing={2} divider={<Divider />}>
                        {/* Aggregate Cell Metrics - Enhanced with Interactivity */}
                        {selectedAsset.type === 'aggregate' && (
                          <>
                            {/* Action Buttons */}
                            <Stack direction="row" spacing={1}>
                              <Tooltip title="Center map on this cell">
                                <Button 
                                  size="small" 
                                  variant="outlined" 
                                  startIcon={<MyLocation />}
                                  onClick={() => flyToAsset(selectedAsset.longitude, selectedAsset.latitude, 12)}
                                  sx={{ flex: 1, fontSize: 11 }}
                                >
                                  Center
                                </Button>
                              </Tooltip>
                              <Tooltip title="Zoom to see individual assets">
                                <Button 
                                  size="small" 
                                  variant="outlined" 
                                  startIcon={<ZoomIn />}
                                  onClick={() => flyToAsset(selectedAsset.longitude, selectedAsset.latitude, 13)}
                                  sx={{ flex: 1, fontSize: 11 }}
                                >
                                  Zoom In
                                </Button>
                              </Tooltip>
                            </Stack>

                            {/* Critical Status Alert */}
                            {selectedAsset.worstStatus === 'critical' && (
                              <Paper sx={{ 
                                p: 1.5, 
                                bgcolor: alpha('#EF4444', 0.1), 
                                border: '1px solid',
                                borderColor: alpha('#EF4444', 0.3)
                              }}>
                                <Stack direction="row" spacing={1} alignItems="center">
                                  <Warning sx={{ color: '#EF4444', fontSize: 20 }} />
                                  <Box>
                                    <Typography variant="caption" fontWeight={700} color="#EF4444">
                                      CRITICAL AREA
                                    </Typography>
                                    <Typography variant="caption" display="block" color="text.secondary">
                                      Requires immediate attention
                                    </Typography>
                                  </Box>
                                </Stack>
                              </Paper>
                            )}

                            {/* Infrastructure Summary - Expandable */}
                            <Box>
                              <Box 
                                display="flex" 
                                justifyContent="space-between" 
                                alignItems="center"
                                sx={{ cursor: 'pointer' }}
                                onClick={() => setExpandedSections(prev => ({ ...prev, infrastructure: !prev.infrastructure }))}
                              >
                                <Stack direction="row" spacing={1} alignItems="center">
                                  <GridOn sx={{ fontSize: 16, color: 'text.secondary' }} />
                                  <Typography variant="caption" color="text.secondary" fontWeight={600}>
                                    INFRASTRUCTURE SUMMARY
                                  </Typography>
                                </Stack>
                                <IconButton size="small">
                                  {expandedSections.infrastructure ? <ExpandLess sx={{ fontSize: 16 }} /> : <ExpandMore sx={{ fontSize: 16 }} />}
                                </IconButton>
                              </Box>
                              
                              <Collapse in={expandedSections.infrastructure}>
                                <Stack spacing={1} mt={1.5}>
                                  <Box display="flex" justifyContent="space-between" alignItems="center">
                                    <Typography variant="body2" color="text.secondary">Total Assets:</Typography>
                                    <Chip 
                                      label={selectedAsset.totalAssets} 
                                      size="small" 
                                      sx={{ fontWeight: 700, minWidth: 50 }}
                                    />
                                  </Box>
                                  
                                  <Paper sx={{ p: 1.5, bgcolor: alpha('#00C8FF', 0.05) }}>
                                    <Box 
                                      sx={{ cursor: 'pointer' }}
                                      onClick={() => {
                                        const activeCardId = 'active_card';
                                        setExpandedAssetCategories(prev => ({
                                          ...prev,
                                          [activeCardId]: {
                                            ...(prev[activeCardId] || {}),
                                            substations: !prev[activeCardId]?.substations,
                                            transformers: prev[activeCardId]?.transformers || false,
                                            poles: prev[activeCardId]?.poles || false,
                                            meters: prev[activeCardId]?.meters || false
                                          }
                                        }));
                                      }}
                                    >
                                      <Stack direction="row" justifyContent="space-between" alignItems="center">
                                        <Stack direction="row" spacing={1} alignItems="center">
                                          <Box sx={{ width: 8, height: 8, borderRadius: '50%', bgcolor: '#00C8FF' }} />
                                          <Typography variant="body2" color="text.secondary">Substations</Typography>
                                        </Stack>
                                        <Stack direction="row" spacing={1} alignItems="center">
                                          <Typography variant="h6" fontWeight={700} color="#00C8FF">
                                            {selectedAsset.substationCount}
                                          </Typography>
                                          <IconButton size="small">
                                            {expandedAssetCategories['active_card']?.substations ? <ExpandLess sx={{ fontSize: 14 }} /> : <ExpandMore sx={{ fontSize: 14 }} />}
                                          </IconButton>
                                        </Stack>
                                      </Stack>
                                    </Box>
                                    
                                    <Collapse in={expandedAssetCategories['active_card']?.substations}>
                                      <Stack spacing={0.5} mt={1} sx={{ maxHeight: 200, overflowY: 'auto' }}>
                                        {selectedAsset.substations?.map((asset: any) => (
                                          <Paper 
                                            key={asset.id}
                                            sx={{ 
                                              p: 1, 
                                              bgcolor: alpha('#00C8FF', 0.08),
                                              cursor: 'pointer',
                                              '&:hover': {
                                                bgcolor: alpha('#00C8FF', 0.15),
                                                transform: 'translateX(4px)',
                                                transition: 'all 0.2s'
                                              }
                                            }}
                                            onClick={() => {
                                              flyToAsset(asset.longitude, asset.latitude, 13.5);
                                              setSelectedAsset(asset);
                                            }}
                                          >
                                            <Stack direction="row" justifyContent="space-between" alignItems="center">
                                              <Box>
                                                <Typography variant="caption" fontWeight={600} color="#00C8FF">
                                                  {asset.name || asset.id}
                                                </Typography>
                                                <Typography variant="caption" display="block" color="text.secondary" sx={{ fontSize: 9 }}>
                                                  Health: {asset.health_score ?? 'N/A'}%
                                                </Typography>
                                              </Box>
                                              <MyLocation sx={{ fontSize: 12, color: alpha('#00C8FF', 0.5) }} />
                                            </Stack>
                                          </Paper>
                                        ))}
                                      </Stack>
                                    </Collapse>
                                  </Paper>
                                  
                                  <Paper sx={{ p: 1.5, bgcolor: alpha('#EC4899', 0.05) }}>
                                    <Box 
                                      sx={{ cursor: 'pointer' }}
                                      onClick={() => {
                                        const activeCardId = 'active_card';
                                        setExpandedAssetCategories(prev => ({
                                          ...prev,
                                          [activeCardId]: {
                                            ...(prev[activeCardId] || {}),
                                            substations: prev[activeCardId]?.substations || false,
                                            transformers: !prev[activeCardId]?.transformers,
                                            poles: prev[activeCardId]?.poles || false,
                                            meters: prev[activeCardId]?.meters || false
                                          }
                                        }));
                                      }}
                                    >
                                      <Stack direction="row" justifyContent="space-between" alignItems="center">
                                        <Stack direction="row" spacing={1} alignItems="center">
                                          <Box sx={{ width: 8, height: 8, borderRadius: '50%', bgcolor: '#EC4899' }} />
                                          <Typography variant="body2" color="text.secondary">Transformers</Typography>
                                        </Stack>
                                        <Stack direction="row" spacing={1} alignItems="center">
                                          <Typography variant="h6" fontWeight={700} color="#EC4899">
                                            {selectedAsset.transformerCount}
                                          </Typography>
                                          <IconButton size="small">
                                            {expandedAssetCategories['active_card']?.transformers ? <ExpandLess sx={{ fontSize: 14 }} /> : <ExpandMore sx={{ fontSize: 14 }} />}
                                          </IconButton>
                                        </Stack>
                                      </Stack>
                                    </Box>
                                    
                                    <Collapse in={expandedAssetCategories['active_card']?.transformers}>
                                      <Stack spacing={0.5} mt={1} sx={{ maxHeight: 200, overflowY: 'auto' }}>
                                        {selectedAsset.transformers?.map((asset: any) => (
                                          <Paper 
                                            key={asset.id}
                                            sx={{ 
                                              p: 1, 
                                              bgcolor: alpha('#EC4899', 0.08),
                                              cursor: 'pointer',
                                              '&:hover': {
                                                bgcolor: alpha('#EC4899', 0.15),
                                                transform: 'translateX(4px)',
                                                transition: 'all 0.2s'
                                              }
                                            }}
                                            onClick={() => {
                                              flyToAsset(asset.longitude, asset.latitude, 13.5);
                                              setSelectedAsset(asset);
                                            }}
                                          >
                                            <Stack direction="row" justifyContent="space-between" alignItems="center">
                                              <Box>
                                                <Typography variant="caption" fontWeight={600} color="#EC4899">
                                                  {asset.name || asset.id}
                                                </Typography>
                                                <Typography variant="caption" display="block" color="text.secondary" sx={{ fontSize: 9 }}>
                                                  Load: {asset.load_percent ?? 'N/A'}% ‚Ä¢ Health: {asset.health_score ?? 'N/A'}%
                                                </Typography>
                                              </Box>
                                              <MyLocation sx={{ fontSize: 12, color: alpha('#EC4899', 0.5) }} />
                                            </Stack>
                                          </Paper>
                                        ))}
                                      </Stack>
                                    </Collapse>
                                  </Paper>
                                  
                                  <Paper sx={{ p: 1.5, bgcolor: alpha('#8880ff', 0.05) }}>
                                    <Box 
                                      sx={{ cursor: 'pointer' }}
                                      onClick={() => {
                                        const activeCardId = 'active_card';
                                        setExpandedAssetCategories(prev => ({
                                          ...prev,
                                          [activeCardId]: {
                                            ...(prev[activeCardId] || {}),
                                            substations: prev[activeCardId]?.substations || false,
                                            transformers: prev[activeCardId]?.transformers || false,
                                            poles: !prev[activeCardId]?.poles,
                                            meters: prev[activeCardId]?.meters || false
                                          }
                                        }));
                                      }}
                                    >
                                      <Stack direction="row" justifyContent="space-between" alignItems="center">
                                        <Stack direction="row" spacing={1} alignItems="center">
                                          <Box sx={{ width: 8, height: 8, borderRadius: '50%', bgcolor: '#8880ff' }} />
                                          <Typography variant="body2" color="text.secondary">Poles</Typography>
                                        </Stack>
                                        <Stack direction="row" spacing={1} alignItems="center">
                                          <Typography variant="h6" fontWeight={700} color="#8880ff">
                                            {selectedAsset.poleCount}
                                          </Typography>
                                          <IconButton size="small">
                                            {expandedAssetCategories['active_card']?.poles ? <ExpandLess sx={{ fontSize: 14 }} /> : <ExpandMore sx={{ fontSize: 14 }} />}
                                          </IconButton>
                                        </Stack>
                                      </Stack>
                                    </Box>
                                    
                                    <Collapse in={expandedAssetCategories['active_card']?.poles}>
                                      <Stack spacing={0.5} mt={1} sx={{ maxHeight: 200, overflowY: 'auto' }}>
                                        {selectedAsset.poles?.map((asset: any) => (
                                          <Paper 
                                            key={asset.id}
                                            sx={{ 
                                              p: 1, 
                                              bgcolor: alpha('#8880ff', 0.08),
                                              cursor: 'pointer',
                                              '&:hover': {
                                                bgcolor: alpha('#8880ff', 0.15),
                                                transform: 'translateX(4px)',
                                                transition: 'all 0.2s'
                                              }
                                            }}
                                            onClick={() => {
                                              flyToAsset(asset.longitude, asset.latitude, 13.5);
                                              setSelectedAsset(asset);
                                            }}
                                          >
                                            <Stack direction="row" justifyContent="space-between" alignItems="center">
                                              <Box>
                                                <Typography variant="caption" fontWeight={600} color="#8880ff">
                                                  {asset.name || asset.id}
                                                </Typography>
                                                <Typography variant="caption" display="block" color="text.secondary" sx={{ fontSize: 9 }}>
                                                  Health: {asset.health_score ?? 'N/A'}%
                                                </Typography>
                                              </Box>
                                              <MyLocation sx={{ fontSize: 12, color: alpha('#8880ff', 0.5) }} />
                                            </Stack>
                                          </Paper>
                                        ))}
                                      </Stack>
                                    </Collapse>
                                  </Paper>
                                  
                                  <Paper sx={{ p: 1.5, bgcolor: alpha('#9333EA', 0.05) }}>
                                    <Box 
                                      sx={{ cursor: 'pointer' }}
                                      onClick={() => {
                                        const activeCardId = 'active_card';
                                        setExpandedAssetCategories(prev => ({
                                          ...prev,
                                          [activeCardId]: {
                                            ...(prev[activeCardId] || {}),
                                            substations: prev[activeCardId]?.substations || false,
                                            transformers: prev[activeCardId]?.transformers || false,
                                            poles: prev[activeCardId]?.poles || false,
                                            meters: !prev[activeCardId]?.meters
                                          }
                                        }));
                                      }}
                                    >
                                      <Stack direction="row" justifyContent="space-between" alignItems="center">
                                        <Stack direction="row" spacing={1} alignItems="center">
                                          <Box sx={{ width: 8, height: 8, borderRadius: '50%', bgcolor: '#9333EA' }} />
                                          <Typography variant="body2" color="text.secondary">Meters</Typography>
                                        </Stack>
                                        <Stack direction="row" spacing={1} alignItems="center">
                                          <Typography variant="h6" fontWeight={700} color="#9333EA">
                                            {selectedAsset.meterCount}
                                          </Typography>
                                          <IconButton size="small">
                                            {expandedAssetCategories['active_card']?.meters ? <ExpandLess sx={{ fontSize: 14 }} /> : <ExpandMore sx={{ fontSize: 14 }} />}
                                          </IconButton>
                                        </Stack>
                                      </Stack>
                                    </Box>
                                    
                                    <Collapse in={expandedAssetCategories['active_card']?.meters}>
                                      <Stack spacing={0.5} mt={1} sx={{ maxHeight: 200, overflowY: 'auto' }}>
                                        {selectedAsset.meters?.map((asset: any) => (
                                          <Paper 
                                            key={asset.id}
                                            sx={{ 
                                              p: 1, 
                                              bgcolor: alpha('#9333EA', 0.08),
                                              cursor: 'pointer',
                                              '&:hover': {
                                                bgcolor: alpha('#9333EA', 0.15),
                                                transform: 'translateX(4px)',
                                                transition: 'all 0.2s'
                                              }
                                            }}
                                            onClick={() => {
                                              flyToAsset(asset.longitude, asset.latitude, 13.5);
                                              setSelectedAsset(asset);
                                            }}
                                          >
                                            <Stack direction="row" justifyContent="space-between" alignItems="center">
                                              <Box>
                                                <Typography variant="caption" fontWeight={600} color="#9333EA">
                                                  {asset.name || asset.id}
                                                </Typography>
                                                <Typography variant="caption" display="block" color="text.secondary" sx={{ fontSize: 9 }}>
                                                  Usage: {asset.current_load ?? 'N/A'} kW
                                                </Typography>
                                              </Box>
                                              <MyLocation sx={{ fontSize: 12, color: alpha('#9333EA', 0.5) }} />
                                            </Stack>
                                          </Paper>
                                        ))}
                                      </Stack>
                                    </Collapse>
                                  </Paper>
                                </Stack>
                              </Collapse>
                            </Box>

                            {/* Health & Load Metrics - Expandable */}
                            <Box>
                              <Box 
                                display="flex" 
                                justifyContent="space-between" 
                                alignItems="center"
                                sx={{ cursor: 'pointer' }}
                                onClick={() => setExpandedSections(prev => ({ ...prev, health: !prev.health }))}
                              >
                                <Stack direction="row" spacing={1} alignItems="center">
                                  <Assessment sx={{ fontSize: 16, color: 'text.secondary' }} />
                                  <Typography variant="caption" color="text.secondary" fontWeight={600}>
                                    PERFORMANCE METRICS
                                  </Typography>
                                </Stack>
                                <IconButton size="small">
                                  {expandedSections.health ? <ExpandLess sx={{ fontSize: 16 }} /> : <ExpandMore sx={{ fontSize: 16 }} />}
                                </IconButton>
                              </Box>
                              
                              <Collapse in={expandedSections.health}>
                                <Stack spacing={2} mt={1.5}>
                                  {/* Average Health */}
                                  <Box>
                                    <Stack direction="row" justifyContent="space-between" alignItems="center" mb={0.5}>
                                      <Typography variant="caption" color="text.secondary" fontWeight={600}>
                                        AVERAGE HEALTH
                                      </Typography>
                                      <Typography variant="h5" sx={{ 
                                        fontWeight: 800, 
                                        color: selectedAsset.avgHealth === null ? '#9CA3AF' : selectedAsset.avgHealth > 70 ? '#22C55E' : selectedAsset.avgHealth > 50 ? '#FBBF24' : '#EF4444' 
                                      }}>
                                        {selectedAsset.avgHealth === null ? 'N/A' : `${selectedAsset.avgHealth}%`}
                                      </Typography>
                                    </Stack>
                                    {selectedAsset.avgHealth !== null && (
                                      <LinearProgress 
                                        variant="determinate" 
                                        value={selectedAsset.avgHealth} 
                                        sx={{ 
                                          height: 8, 
                                          borderRadius: 1,
                                          bgcolor: alpha('#fff', 0.1),
                                          '& .MuiLinearProgress-bar': {
                                            bgcolor: selectedAsset.avgHealth > 70 ? '#22C55E' : selectedAsset.avgHealth > 50 ? '#FBBF24' : '#EF4444'
                                          }
                                        }} 
                                      />
                                    )}
                                    {selectedAsset.avgHealth === null && (
                                      <Typography variant="caption" color="text.secondary" sx={{ display: 'block', mt: 0.5, fontStyle: 'italic' }}>
                                        No health sensors in this cell
                                      </Typography>
                                    )}
                                  </Box>

                                  {/* Average Load */}
                                  <Box>
                                    <Stack direction="row" justifyContent="space-between" alignItems="center" mb={0.5}>
                                      <Typography variant="caption" color="text.secondary" fontWeight={600}>
                                        AVERAGE LOAD (TRANSFORMERS)
                                      </Typography>
                                      <Typography variant="h5" sx={{ 
                                        fontWeight: 800, 
                                        color: selectedAsset.avgLoad > 85 ? '#EF4444' : selectedAsset.avgLoad > 70 ? '#FBBF24' : '#22C55E'
                                      }}>
                                        {selectedAsset.avgLoad}%
                                      </Typography>
                                    </Stack>
                                    <LinearProgress 
                                      variant="determinate" 
                                      value={selectedAsset.avgLoad} 
                                      sx={{ 
                                        height: 8, 
                                        borderRadius: 1,
                                        bgcolor: alpha('#fff', 0.1),
                                        '& .MuiLinearProgress-bar': {
                                          bgcolor: selectedAsset.avgLoad > 85 ? '#EF4444' : selectedAsset.avgLoad > 70 ? '#FBBF24' : '#22C55E'
                                        }
                                      }} 
                                    />
                                  </Box>

                                  {/* Status Badge */}
                                  <Box>
                                    <Typography variant="caption" color="text.secondary" fontWeight={600} display="block" mb={0.5}>
                                      OPERATIONAL STATUS
                                    </Typography>
                                    <Chip 
                                      icon={selectedAsset.worstStatus === 'critical' ? <Warning /> : undefined}
                                      label={selectedAsset.worstStatus.toUpperCase()} 
                                      sx={{ 
                                        width: '100%',
                                        bgcolor: selectedAsset.worstStatus === 'critical' ? alpha('#EF4444', 0.2) :
                                                 selectedAsset.worstStatus === 'warning' ? alpha('#FBBF24', 0.2) :
                                                 alpha('#22C55E', 0.2),
                                        color: selectedAsset.worstStatus === 'critical' ? '#EF4444' :
                                               selectedAsset.worstStatus === 'warning' ? '#FBBF24' :
                                               '#22C55E',
                                        fontWeight: 700,
                                        fontSize: 12,
                                        height: 32
                                      }} 
                                    />
                                  </Box>
                                </Stack>
                              </Collapse>
                            </Box>

                            {/* Health Status Breakdown - Expandable */}
                            <Box>
                              <Box
                                display="flex"
                                justifyContent="space-between"
                                alignItems="center"
                                sx={{ cursor: 'pointer' }}
                                onClick={() => setExpandedSections(prev => ({ ...prev, healthStatus: !prev.healthStatus }))}
                              >
                                <Stack direction="row" spacing={1} alignItems="center">
                                  <FavoriteOutlined sx={{ fontSize: 16, color: 'text.secondary' }} />
                                  <Typography variant="caption" color="text.secondary" fontWeight={600}>
                                    HEALTH STATUS
                                  </Typography>
                                </Stack>
                                <IconButton size="small">
                                  {expandedSections.healthStatus ? <ExpandLess sx={{ fontSize: 16 }} /> : <ExpandMore sx={{ fontSize: 16 }} />}
                                </IconButton>
                              </Box>
                              
                              <Collapse in={expandedSections.healthStatus}>
                                <Stack spacing={2} mt={1.5}>
                                  {/* Overall Counts */}
                                  <Stack spacing={1}>
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                      <Typography variant="body2" color="text.secondary">Critical Assets</Typography>
                                      <Chip label={selectedAsset.criticalCount || 0} size="small" sx={{ bgcolor: alpha('#EF4444', 0.15), color: '#EF4444' }} />
                                    </Box>
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                      <Typography variant="body2" color="text.secondary">Warning Assets</Typography>
                                      <Chip label={selectedAsset.warningCount || 0} size="small" sx={{ bgcolor: alpha('#FBBF24', 0.15), color: '#FBBF24' }} />
                                    </Box>
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                      <Typography variant="body2" color="text.secondary">Healthy Assets</Typography>
                                      <Chip label={selectedAsset.healthyCount || 0} size="small" sx={{ bgcolor: alpha('#22C55E', 0.15), color: '#22C55E' }} />
                                    </Box>
                                  </Stack>

                                  {/* Breakdown by Asset Type */}
                                  {selectedAsset.healthByType && (
                                    <Stack spacing={1.5} sx={{ pl: 1 }}>
                                      {/* Substations */}
                                      {(selectedAsset.healthByType.substations.critical > 0 || 
                                        selectedAsset.healthByType.substations.warning > 0 || 
                                        selectedAsset.healthByType.substations.healthy > 0) && (
                                        <Box>
                                          <Typography variant="caption" fontWeight={600} sx={{ color: '#00C8FF', mb: 0.5, display: 'block' }}>
                                            Substations
                                          </Typography>
                                          <Stack spacing={0.5} sx={{ pl: 1 }}>
                                            {selectedAsset.healthByType.substations.critical > 0 && (
                                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <Typography variant="caption" color="text.secondary">Critical</Typography>
                                                <Chip label={selectedAsset.healthByType.substations.critical} size="small" sx={{ height: 18, fontSize: 10, bgcolor: alpha('#EF4444', 0.15), color: '#EF4444' }} />
                                              </Box>
                                            )}
                                            {selectedAsset.healthByType.substations.warning > 0 && (
                                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <Typography variant="caption" color="text.secondary">Warning</Typography>
                                                <Chip label={selectedAsset.healthByType.substations.warning} size="small" sx={{ height: 18, fontSize: 10, bgcolor: alpha('#FBBF24', 0.15), color: '#FBBF24' }} />
                                              </Box>
                                            )}
                                            {selectedAsset.healthByType.substations.healthy > 0 && (
                                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <Typography variant="caption" color="text.secondary">Healthy</Typography>
                                                <Chip label={selectedAsset.healthByType.substations.healthy} size="small" sx={{ height: 18, fontSize: 10, bgcolor: alpha('#22C55E', 0.15), color: '#22C55E' }} />
                                              </Box>
                                            )}
                                          </Stack>
                                        </Box>
                                      )}
                                      
                                      {/* Transformers */}
                                      {(selectedAsset.healthByType.transformers.critical > 0 || 
                                        selectedAsset.healthByType.transformers.warning > 0 || 
                                        selectedAsset.healthByType.transformers.healthy > 0) && (
                                        <Box>
                                          <Typography variant="caption" fontWeight={600} sx={{ color: '#EC4899', mb: 0.5, display: 'block' }}>
                                            Transformers
                                          </Typography>
                                          <Stack spacing={0.5} sx={{ pl: 1 }}>
                                            {selectedAsset.healthByType.transformers.critical > 0 && (
                                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <Typography variant="caption" color="text.secondary">Critical</Typography>
                                                <Chip label={selectedAsset.healthByType.transformers.critical} size="small" sx={{ height: 18, fontSize: 10, bgcolor: alpha('#EF4444', 0.15), color: '#EF4444' }} />
                                              </Box>
                                            )}
                                            {selectedAsset.healthByType.transformers.warning > 0 && (
                                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <Typography variant="caption" color="text.secondary">Warning</Typography>
                                                <Chip label={selectedAsset.healthByType.transformers.warning} size="small" sx={{ height: 18, fontSize: 10, bgcolor: alpha('#FBBF24', 0.15), color: '#FBBF24' }} />
                                              </Box>
                                            )}
                                            {selectedAsset.healthByType.transformers.healthy > 0 && (
                                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <Typography variant="caption" color="text.secondary">Healthy</Typography>
                                                <Chip label={selectedAsset.healthByType.transformers.healthy} size="small" sx={{ height: 18, fontSize: 10, bgcolor: alpha('#22C55E', 0.15), color: '#22C55E' }} />
                                              </Box>
                                            )}
                                          </Stack>
                                        </Box>
                                      )}
                                      
                                      {/* Poles */}
                                      {(selectedAsset.healthByType.poles.critical > 0 || 
                                        selectedAsset.healthByType.poles.warning > 0 || 
                                        selectedAsset.healthByType.poles.healthy > 0) && (
                                        <Box>
                                          <Typography variant="caption" fontWeight={600} sx={{ color: '#8880ff', mb: 0.5, display: 'block' }}>
                                            Poles
                                          </Typography>
                                          <Stack spacing={0.5} sx={{ pl: 1 }}>
                                            {selectedAsset.healthByType.poles.critical > 0 && (
                                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <Typography variant="caption" color="text.secondary">Critical</Typography>
                                                <Chip label={selectedAsset.healthByType.poles.critical} size="small" sx={{ height: 18, fontSize: 10, bgcolor: alpha('#EF4444', 0.15), color: '#EF4444' }} />
                                              </Box>
                                            )}
                                            {selectedAsset.healthByType.poles.warning > 0 && (
                                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <Typography variant="caption" color="text.secondary">Warning</Typography>
                                                <Chip label={selectedAsset.healthByType.poles.warning} size="small" sx={{ height: 18, fontSize: 10, bgcolor: alpha('#FBBF24', 0.15), color: '#FBBF24' }} />
                                              </Box>
                                            )}
                                            {selectedAsset.healthByType.poles.healthy > 0 && (
                                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <Typography variant="caption" color="text.secondary">Healthy</Typography>
                                                <Chip label={selectedAsset.healthByType.poles.healthy} size="small" sx={{ height: 18, fontSize: 10, bgcolor: alpha('#22C55E', 0.15), color: '#22C55E' }} />
                                              </Box>
                                            )}
                                          </Stack>
                                        </Box>
                                      )}
                                      
                                      {/* Meters */}
                                      {(selectedAsset.healthByType.meters.critical > 0 || 
                                        selectedAsset.healthByType.meters.warning > 0 || 
                                        selectedAsset.healthByType.meters.healthy > 0) && (
                                        <Box>
                                          <Typography variant="caption" fontWeight={600} sx={{ color: '#9333EA', mb: 0.5, display: 'block' }}>
                                            Meters
                                          </Typography>
                                          <Stack spacing={0.5} sx={{ pl: 1 }}>
                                            {selectedAsset.healthByType.meters.critical > 0 && (
                                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <Typography variant="caption" color="text.secondary">Critical</Typography>
                                                <Chip label={selectedAsset.healthByType.meters.critical} size="small" sx={{ height: 18, fontSize: 10, bgcolor: alpha('#EF4444', 0.15), color: '#EF4444' }} />
                                              </Box>
                                            )}
                                            {selectedAsset.healthByType.meters.warning > 0 && (
                                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <Typography variant="caption" color="text.secondary">Warning</Typography>
                                                <Chip label={selectedAsset.healthByType.meters.warning} size="small" sx={{ height: 18, fontSize: 10, bgcolor: alpha('#FBBF24', 0.15), color: '#FBBF24' }} />
                                              </Box>
                                            )}
                                            {selectedAsset.healthByType.meters.healthy > 0 && (
                                              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <Typography variant="caption" color="text.secondary">Healthy</Typography>
                                                <Chip label={selectedAsset.healthByType.meters.healthy} size="small" sx={{ height: 18, fontSize: 10, bgcolor: alpha('#22C55E', 0.15), color: '#22C55E' }} />
                                              </Box>
                                            )}
                                          </Stack>
                                        </Box>
                                      )}
                                    </Stack>
                                  )}
                                </Stack>
                              </Collapse>
                            </Box>

                            {/* Cell Center Coordinates */}
                            <Box>
                              <Typography variant="caption" color="text.secondary" fontWeight={600} display="block" mb={0.5}>
                                CELL CENTER
                              </Typography>
                              <Paper sx={{ p: 1, bgcolor: alpha('#0EA5E9', 0.05) }}>
                                <Typography variant="body2" sx={{ fontFamily: 'monospace', fontSize: 11, color: '#0EA5E9' }}>
                                  {selectedAsset.latitude.toFixed(6)}, {selectedAsset.longitude.toFixed(6)}
                                </Typography>
                              </Paper>
                            </Box>
                          </>
                        )}

                        {/* Individual Asset Metrics */}
                        {selectedAsset.health_score !== undefined && selectedAsset.health_score !== null && (
                          <Box>
                            <Typography variant="caption" color="text.secondary" fontWeight={600}>HEALTH SCORE</Typography>
                            <Typography variant="h4" sx={{ 
                              fontWeight: 800, 
                              color: selectedAsset.health_score > 80 ? '#22C55E' : selectedAsset.health_score > 50 ? '#FBBF24' : '#EF4444' 
                            }}>
                              {selectedAsset.health_score.toFixed(0)}%
                            </Typography>
                          </Box>
                        )}

                        {selectedAsset.load_percent !== undefined && selectedAsset.load_percent !== null && (
                          <Box>
                            <Typography variant="caption" color="text.secondary" fontWeight={600}>LOAD CAPACITY</Typography>
                            <Typography variant="h4" sx={{ 
                              fontWeight: 800, 
                              color: selectedAsset.load_percent > 85 ? '#EF4444' : 
                                     selectedAsset.load_percent > 70 ? '#FBBF24' : 
                                     '#22C55E'
                            }}>
                              {selectedAsset.load_percent.toFixed(0)}%
                            </Typography>
                            <LinearProgress 
                              variant="determinate" 
                              value={selectedAsset.load_percent} 
                              sx={{ 
                                height: 6, 
                                borderRadius: 1,
                                mt: 1,
                                bgcolor: alpha('#fff', 0.1),
                                '& .MuiLinearProgress-bar': {
                                  bgcolor: selectedAsset.load_percent > 85 ? '#EF4444' : 
                                           selectedAsset.load_percent > 70 ? '#FBBF24' : 
                                           '#22C55E'
                                }
                              }} 
                            />
                          </Box>
                        )}

                        {selectedAsset.usage_kwh !== undefined && selectedAsset.usage_kwh !== null && (
                          <Box>
                            <Typography variant="caption" color="text.secondary" fontWeight={600}>POWER USAGE</Typography>
                            <Typography variant="h4" sx={{ fontWeight: 800, color: '#9333EA' }}>
                              {selectedAsset.usage_kwh.toFixed(1)} kWh
                            </Typography>
                          </Box>
                        )}

                        {selectedAsset.voltage && (
                          <Box>
                            <Typography variant="caption" color="text.secondary">Voltage Class</Typography>
                            <Typography variant="body1" fontWeight={600}>{selectedAsset.voltage}</Typography>
                          </Box>
                        )}

                        {selectedAsset.status && (
                          <Box>
                            <Typography variant="caption" color="text.secondary" sx={{ display: 'block', mb: 1 }}>Operational Status</Typography>
                            <Chip 
                              label={(() => {
                                // Derive status from load capacity for transformers
                                if (selectedAsset.type === 'transformer' && selectedAsset.load_percent !== undefined) {
                                  if (selectedAsset.load_percent > 85) return 'Critical Load';
                                  if (selectedAsset.load_percent > 70) return 'High Load';
                                  return 'Operational';
                                }
                                // Derive status from health score for other assets
                                if (selectedAsset.health_score !== undefined && selectedAsset.health_score !== null) {
                                  if (selectedAsset.health_score < 60) return 'Critical';
                                  if (selectedAsset.health_score < 80) return 'Fair';
                                  return 'Excellent';
                                }
                                return selectedAsset.status;
                              })()} 
                              size="small" 
                              sx={{ 
                                mt: 0.5,
                                bgcolor: (() => {
                                  // Status color based on load capacity for transformers
                                  if (selectedAsset.type === 'transformer' && selectedAsset.load_percent !== undefined) {
                                    if (selectedAsset.load_percent > 85) return alpha('#EF4444', 0.2);
                                    if (selectedAsset.load_percent > 70) return alpha('#FBBF24', 0.2);
                                    return alpha('#22C55E', 0.2);
                                  }
                                  // Status color based on health score for other assets
                                  if (selectedAsset.health_score !== undefined && selectedAsset.health_score !== null) {
                                    if (selectedAsset.health_score < 60) return alpha('#EF4444', 0.2);
                                    if (selectedAsset.health_score < 80) return alpha('#FBBF24', 0.2);
                                    return alpha('#22C55E', 0.2);
                                  }
                                  // Fallback: status string-based coloring
                                  return selectedAsset.status.includes('Operational') || selectedAsset.status.includes('Active') || 
                                         selectedAsset.status.includes('Connected') || selectedAsset.status.includes('Healthy') ||
                                         selectedAsset.status.includes('Good') || selectedAsset.status.includes('Excellent')
                                    ? alpha('#22C55E', 0.2) 
                                    : alpha('#F59E0B', 0.2);
                                })(),
                                color: (() => {
                                  // Status color based on load capacity for transformers
                                  if (selectedAsset.type === 'transformer' && selectedAsset.load_percent !== undefined) {
                                    if (selectedAsset.load_percent > 85) return '#EF4444';
                                    if (selectedAsset.load_percent > 70) return '#FBBF24';
                                    return '#22C55E';
                                  }
                                  // Status color based on health score for other assets
                                  if (selectedAsset.health_score !== undefined && selectedAsset.health_score !== null) {
                                    if (selectedAsset.health_score < 60) return '#EF4444';
                                    if (selectedAsset.health_score < 80) return '#FBBF24';
                                    return '#22C55E';
                                  }
                                  // Fallback: status string-based coloring
                                  return selectedAsset.status.includes('Operational') || selectedAsset.status.includes('Active') || 
                                         selectedAsset.status.includes('Connected') || selectedAsset.status.includes('Healthy') ||
                                         selectedAsset.status.includes('Good') || selectedAsset.status.includes('Excellent')
                                    ? '#22C55E' 
                                    : '#F59E0B';
                                })(),
                                fontWeight: 700
                              }} 
                            />
                          </Box>
                        )}

                        {selectedAsset.last_maintenance && (
                          <Box>
                            <Typography variant="caption" color="text.secondary">Last Maintenance</Typography>
                            <Typography variant="body2">{selectedAsset.last_maintenance}</Typography>
                          </Box>
                        )}

                        {selectedAsset.commissioned_date && (
                          <Box>
                            <Typography variant="caption" color="text.secondary">Commissioned</Typography>
                            <Typography variant="body2">
                              {selectedAsset.commissioned_date}
                              {(() => {
                                try {
                                  const commissionedYear = new Date(selectedAsset.commissioned_date).getFullYear();
                                  const currentYear = new Date().getFullYear();
                                  const age = currentYear - commissionedYear;
                                  return age > 0 ? ` (${age} years old)` : '';
                                } catch {
                                  return '';
                                }
                              })()}
                            </Typography>
                          </Box>
                        )}

                        {selectedAsset.type === 'pole' && selectedAsset.pole_height_ft && (
                          <Box>
                            <Typography variant="caption" color="text.secondary">Pole Height</Typography>
                            <Typography variant="body2" sx={{ color: '#8880ff', fontWeight: 600 }}>
                              {selectedAsset.pole_height_ft} ft
                            </Typography>
                          </Box>
                        )}

                        {selectedAsset.type !== 'aggregate' && (
                          <Box>
                            <Typography variant="caption" color="text.secondary">Coordinates</Typography>
                            <Typography variant="body2" sx={{ fontFamily: 'monospace', fontSize: 11 }}>
                              {selectedAsset.latitude.toFixed(6)}, {selectedAsset.longitude.toFixed(6)}
                            </Typography>
                          </Box>
                        )}
                      </Stack>
                      </Paper>
                    </Fade>
                  );
                })()}

              </Box>
            </>
          )}

          {currentTab > 0 && (
            <Box sx={{ flexGrow: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
              <Typography variant="h6" color="text.secondary">
                {['Network Topology', 'Asset Health', 'AMI Analytics', 'Outage Management'][currentTab - 1]} - Coming Soon
              </Typography>
            </Box>
          )}
        </Box>

      </Box>
    </ThemeProvider>
  );
}

export default App;
